%include "flightplan.dbh"
%define VIEW_LOOKAT_NOTHING 0
%define VIEW_LOOKAT_VEHICLE 1

%define VIEW_COCKPIT   0
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_NOTHING :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 0.1f      :view position change per keypress (ft);
  float viewAngStep = 2.5f/57.3f :view angle change per keypress (rad);
  float jumpStep = 300.0f      :jump view at this dist, certain modes (ft);
  float seat[3] ={2.5,0.0f,0.0f}:eye position with repect to vehicle;
  float neckPhi     = 0.0      :view angle with respect to vehicle;
  float neckTheta   = 0.0      :view angle with respect to vehicle;
  float neckPsi     = 0.0      :view angle with respect to vehicle;
  int rotate        = 0        :rotate;
  float fovscale    = 1        :scaling fov when rotating view;
  char hudOn = 1 :show HUD;
  char followWaypoints = 0 :if one waypoint, use this instead of vehicle;
} gcs0view_cockpit, gcs1view_cockpit, gcs2view_cockpit, gcs3view_cockpit;

%define VIEW_NAV 1
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 100.0f :zoom factor;
  float viewStep    = 25.0f      :view position change per keypress (ft);
  float seat[3] ={-0.0f,0.0f,-0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs0view_nav;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 100.0f :zoom factor;
  float viewStep    = 25.0f      :view position change per keypress (ft);
  float seat[3] ={-0.0f,0.0f,-0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs1view_nav;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 100.0f :zoom factor;
  float viewStep    = 25.0f      :view position change per keypress (ft);
  float seat[3] ={-0.0f,0.0f,-0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs2view_nav;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 100.0f :zoom factor;
  float viewStep    = 25.0f      :view position change per keypress (ft);
  float seat[3] ={-0.0f,0.0f,-0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs3view_nav;

%define VIEW_CHASE 2
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f      :view position change per keypress (ft);
  float seat[3] ={-15.0f,15.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs0view_chase;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f      :view position change per keypress (ft);
  float seat[3] ={-15.0f,15.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs1view_chase;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f      :view position change per keypress (ft);
  float seat[3] ={-15.0f,15.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs2view_chase;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f      :view position change per keypress (ft);
  float seat[3] ={-15.0f,15.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs3view_chase;

%define VIEW_GROUND 3
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f     :view position change per keypress (ft);
  float seat[3] ={420.0,-145.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs0view_ground;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f     :view position change per keypress (ft);
  float seat[3] ={420.0,-145.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs1view_ground;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f     :view position change per keypress (ft);
  float seat[3] ={420.0,-145.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs2view_ground;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 1.0f :zoom factor;
  float viewStep    = 1.0f     :view position change per keypress (ft);
  float seat[3] ={420.0,-145.0f,-5.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs3view_ground;

%define VIEW_HOVER 4
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 0.5f :zoom factor;
  float viewStep    = 2.5f     :view position change per keypress (ft);
  float jumpStep = 100.0f      :jump view at this dist, certain modes (ft);
  float seat[3] ={0.0,0.0,0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs0view_hover;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 0.5f :zoom factor;
  float viewStep    = 2.5f     :view position change per keypress (ft);
  float jumpStep = 100.0f      :jump view at this dist, certain modes (ft);
  float seat[3] ={0.0,0.0,0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs1view_hover;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 0.5f :zoom factor;
  float viewStep    = 2.5f     :view position change per keypress (ft);
  float jumpStep = 100.0f      :jump view at this dist, certain modes (ft);
  float seat[3] ={0.0,0.0,0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs2view_hover;
%Dir view_ref {
  int   lookat = VIEW_LOOKAT_VEHICLE :0=nothing 1=vehicle;
  float zoom = 0.5f :zoom factor;
  float viewStep    = 2.5f     :view position change per keypress (ft);
  float jumpStep = 100.0f      :jump view at this dist, certain modes (ft);
  float seat[3] ={0.0,0.0,0.0f}:eye position with repect to vehicle;
  char hudOn = 0 :show HUD;
} gcs3view_hover;

%define VIEW_CAMERA 5
%define VIEW_CAMERA2 9
%define VIEW_CAMERA3 10
%define VIEW_CAMERA4 11
%define VIEW_IPRESULTS 7
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs0view_camera;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs0view_camera2;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs0view_camera3;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs0view_camera4;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs1view_camera;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs1view_camera2;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs1view_camera3;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs1view_camera4;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs2view_camera;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs2view_camera2;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs2view_camera3;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs2view_camera4;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs3view_camera;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs3view_camera2;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs3view_camera3;
%Dir view_ref {
  float zoom = 1.75f :zoom factor;
  float viewStep    = 2.5f      :view position change per keypress (ft);
  char hudOn = 0 :show HUD;
} gcs3view_camera4;

%Dir imViewer_ref {
  char init=1: 1- init with local file, 2- init with remote file ;
  char run=0:  running ;
  char goodImage=0: ;
  char sim=1: we are working in the sim ;
  char save=0: save image on ground;
  char output=0: 0-navip 1-visionNav 2-visionFormation;
  int nameCounter=0: ;
  int sessionCounter=0: ;
  int width=352: ;
  int height=240: ;
  int size=352*240: ;
  int ipPoints[2]={0,0}: ;
  int cnrPoints[4][2]       = {{0,0},{0,0},{0,0},{0,0}} : ;
  double VehicleLocation[3][2] = {{0,0},{0,0},{0,0}}       : IP data for visionFormation;
  string headername = "./headerOut.dat\0                                        ": ;
  string bitmapname = "./bitmapOut.dat\0                                        ": ;
  string savefilename = "./bitmap.bmp\0                                        ": ;
  double lastTime=0: last time initialization was attempted;
  double initDt=0.5: time between initialization attempts;
  double lastsave=0: last time save was attempted;
  double savedt=0.5: time between save attempts;
} imViewer;

%define LOOKAT_TRUTH 0
%define LOOKAT_GCS 1
%define LOOKAT_BOTH 2

%define HORIZONPTS 60

%Dir scThreats_ref {
  int number = 1 :number of threats present;
  float height = 20.0f: height of threats in scene;
  float startx = 0: starting point of trajectory in LC;
  float starty = 0: starting point of trajectory in LC;
  float xy[10][2]= {{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0},{0,0}}: x,y position of threats in local frame (ft);
  float rad[10]= {5.0f,5.0f,5.0f,5.0f,5.0f,0,0,0,0,0}: radius of the threats in local frame (ft);
} scThreats;

%define VIEWMENUITEMS 5
%define VISMENUITEMS  12
%define WAYMENUITEMS  16
%define TYPEMENUITEMS 9
%define VELMENUITEMS  12
%define ALTMENUITEMS  11
%define HEADMENUITEMS 10
%define MODEMENUITEMS 7
%define CUSTOMMENUITEMS 11

%define SCENE_NUMBEROFOVERLAYS 10
%Dir sceneOverlay_ref {
  string file = "mlf4.kml\0                      " :file name of ground texture;
  double lat = 33.659653    :center of ground texture;
  double lon = -84.663333   :center of ground texture;
  double offset[2] = {0,0}    :offset texture (ft NE);
  double length = 2597*2 :length (N/S) of ground texture square;
  double width  = 2597*2 :width (E/W) of ground texture square;
  double rotation = 0.0 :(deg) rotation clockwise;
  float rgba[4] = {1.0f,1.0f,1.0f,1.0f} :red, green, blue, alpha;
  int successFlag = 0 :successful texture load flag;
  int dl       = 0 :display list;
} sceneOverlay0;

%Dir sceneOverlay_ref {
  string file = "mlf3.kml\0                      " :file name of ground texture;
  double offset[2] = {0,0}   :offset texture (ft NE);
  double length = 760*2  :length (N/S) of ground texture square;
  double width  = 760*2  :width (E/W) of ground texture square;
} sceneOverlay1;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay2;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay3;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay4;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay5;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay6;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay7;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay8;

%Dir sceneOverlay_ref {
  string file = "\0                              " :file name of ground texture;
} sceneOverlay9;

%Dir internetOverlay_ref {
  string cachePath = "cache\0                                         " :location of files;
  string url       = "http://maps.google.com/maps/api/\0                                                                                " :url of google maps;
  string urlBing   = "http://dev.virtualearth.net/REST/v1/Imagery/Map/\0                                                                " :url of bing maps;
  string keyBing   = "\0                                                                                                                " :bing key;
  string suffix    = "\0                                                                                                                " :extra options;
  int zoom = 17  :zoom level to use (0-20 or so);
  int size = 512 :limited to 640;
  char mapType    = 1 :0=road,1=sat,2=hybrid,3=terrain,4=bingSat,5=bingHybrid;
  char autoZoom   = 1 :autozoom switch;
  char useNetwork = 1 :load maps from internet;
  int zoomMin = 6  :min zoom level;
  int zoomMax = 19 :max zoom level;
  double fudge = 1.5 :fudge auto zoom level;
  double latprec = 0 :latitude precision (calculated);
  double requiredWidth = 0 :(ft) (calculated);
  double width = 0 :(ft) (calculated);
  double lat = 300.0 :(deg);
  double lon = 300.0 :(deg);
  int successFlag = 0 :texture load;
  double poseKMLScale = 2 :scale of DAE file;
  string poseKMLFileName = "heli.dae\0                             " :file name;
  double poseKMLdt = 0.5 :(sec) update time step of pose KML file;
  double poseKMLLastTime = -1 :(sec) time of last update;
  int retryPeriod = 40 :for loading file;
  char loaderThreadRunning = 0 :loader thread running;
  int threadid = -1 : ;
  int maxTileScenario = 3 :1 or 3;
  int tileScenario = 0 : ;
} internetOverlay;

%Dir sceneControlFunctionKeys_ref {
  string f1 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  string f2 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  string f3 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  string f4 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  string f5 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  string f6 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  string f7 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  string f8 = "01234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
} sceneControlFunctionKeys;

%define SCENE_CHECKLIST_MAXITEMS 50
%Dir sceneChecklistItem_ref {
  string text    = "\0 12345678901234567890123456789012345678901234567890123456789012345678901234567890" :to display for item;
  string command = "\0 12345678901234567890123456789012345678901234567890123456789012345678901234567890" :to run when becomes the active item;
} sceneChecklistItem[50];

%Dir sceneChecklist_ref {
  int activeItem = SCENE_CHECKLIST_MAXITEMS : ;
  dir sceneChecklistItem_ref item[50] = sceneChecklistItem[50] : ;
} sceneChecklist;

%define SPEED_FPS 0
%define SPEED_KNOTS 1
%define SPEED_KPH 2
%define SPEED_MPH 3
%define SPEED_MPS 4

%define DISTANCE_FT 0
%define DISTANCE_M 1
%define DISTANCE_NM 2
%define DISTANCE_KM 3
%define DISTANCE_SM 4

%define POS_FEET 0
%define POS_LATLONG 1

%define MAPUP_CONST 0
%define MAPUP_HEADING 1
%define MAPUP_TRACK 2

%enum overlaySource {OVERLAY_KML=0,OVERLAY_GOOGLETYPE1=1,OVERLAY_GOOGLETYPE2=2,OVERLAY_BINGAERIAL=3,OVERLAY_BINGAERIALWITHLABELS=4,
OVERLAY_GOOGLETYPEUNKNOWN=8,OVERLAY_GOOGLETYPE1_AND_KML=9,OVERLAY_BINGUNKNOWN=10,OVERLAY_BING_AND_KML=11};

%Dir sceneCustomMenuItem_ref {
  string name    = "\0                                                 " :name;
  string command = "\0                                                                                                         " :command to execute;
  char acting = 0 :indicate action being taken;
} sceneCustomMenuItem[10];

%Dir sceneCustomMenu_ref {
  char on = 0 :use custom menu;
  string nameOpen   = "\0                                                 " :name when open;
  string nameClosed = "\0                                                 " :name when open;
  dir sceneCustomMenuItem_ref item[10] = sceneCustomMenuItem[10] : ;
} sceneCustomMenu;

%Dir sphereObstacle_ref {
	int   whichColor     = 0 : 0-use global color (sceneGlobal.obstacleColor), 1- use local color (sphereObstacle[i].color);
	int   hasTether      = 0 : ;
	float radius         = 1.0 : Obstacle radius (scale from base radius);
	float location[3]    = {0.0, 0.0, 0.0} : Obstacle location in local frame;
	Float color[4]       = { 0.7f, 0.7f, 1.0f, 1.0 } : ;
	Float tetherColor[4] = {1.0f,1.0f,1.0f,1.0f} : ;
} sphereObstacle[8];

%Dir sceneOverlays_ref {
  dir sceneOverlay_ref m0 = sceneOverlay0 :map overlay;
  dir sceneOverlay_ref m1 = sceneOverlay1 :map overlay;
  dir sceneOverlay_ref m2 = sceneOverlay2 :map overlay;
  dir sceneOverlay_ref m3 = sceneOverlay3 :map overlay;
  dir sceneOverlay_ref m4 = sceneOverlay4 :map overlay;
  dir sceneOverlay_ref m5 = sceneOverlay5 :map overlay;
  dir sceneOverlay_ref m6 = sceneOverlay6 :map overlay;
  dir sceneOverlay_ref m7 = sceneOverlay7 :map overlay;
  dir sceneOverlay_ref m8 = sceneOverlay8 :map overlay;
  dir sceneOverlay_ref m9 = sceneOverlay9 :map overlay;
} sceneOverlays;

%define SCENE_ANNOTATIONS 500
%enum annotationType {ANNOTATION_OFF=0,ANNOTATION_CYLINDER=1,ANNOTATION_MARKER=2};
%Dir sceneAnnotation_ref {
  int type = ANNOTATION_OFF :(annotationType);
  double latitude  = 33.657085  :deg-N;
  double longitude = -84.666999 :deg-E;
  double height = 1000  :(ft) MSL;
  double radius = 100  :(ft);
  Float color[4] = {1,1,1,1} : ;
  string text = "\0                                                                   " : ;
} sceneAnnotation[500];

%Dir sceneAnnotations_ref {
  dir sceneAnnotation_ref object[500] = sceneAnnotation[500] : ;
} sceneAnnotations;

%Dir sceneGlobal_ref {
  dir  sceneOverlays_ref overlays      = sceneOverlays : ;
  dir  internetOverlay_ref io          = internetOverlay :map overlays from google or bing;
  dir  dted_ref         dted           = sceneDTED   :DTED data;
  char overlaySource                   = OVERLAY_KML :(overlaySource) 0 = kml, 1 = google map basic, 2 = google map with labels, 3 = bing, 4 = bing with labels, 9 = kml+google basic;
  char outputGoogleEarth               = 0 :update gelink.kml in real time;
  char useSRTM                         = 0 :use SRTM data if available;
  dir  sceneChecklist_ref checklist    = sceneChecklist :electronic checklist;
  dir  sceneControlFunctionKeys_ref cf = sceneControlFunctionKeys :ctrl func key assignments;
  dir  sceneCustomMenu_ref customMenu  = sceneCustomMenu :custom menu selections;
  dir  sceneAnnotations_ref annotate   = sceneAnnotations :special markers;

  int switchit[4]  = {0,0,0,0} : ;
  int videoTexSize = 256 :for video mode texture;
  int fog          = 0     :enable fog;
  int antialias    = 1     :antialias lines in scene;
  int useNewEdge   = 0     :flag for using new edge graphic;
  dir multirotorModel_ref multirotor    = multirotorModel : ;

  dir sphereObstacle_ref  sphereObstacle[8]      = sphereObstacle[8] : ;
  dir gtarDesk_ref        gtarDesk               = gtarDesk          : ;
  dir gtarswitchpost_ref  gtarswitchpost         = gtarswitchpost    : ;
  dir gtarRover_ref       gtarRover              = gtarRover         : ;
  dir gtarRover_ref       gtarAHS2               = gtarAHS2        : ;
  dir gtarRover_ref       gtarAHS3               = gtarAHS3        : ;
  dir gtarRover_ref       gtarAHS4               = gtarAHS4        : ;
  dir sceneMbzirc_ref     sceneMbzirc            = sceneMbzirc  : ;
  dir sceneGtarPylns_ref  gtarPylns              = sceneGtarPylns    : ;
  dir sceneRoombaTargets_ref       roombaTargets = sceneRoombaTargets  : ;
  dir randPolygons_ref    randPolygons           = randPolygons      : ;
  dir bannerObstacle_ref  bannerObstacle         = bannerObstacle    : ;
  dir gtarAHS_ref         gtarAHS                = gtarAHS           : ;
  dir pictureObstacle_ref pictureObstacle        = pictureObstacle   : ;
  dir scanPoints_ref keyScan                     = keyScan     : key frame scan points ;
  dir scanPoints_ref currentScan                 = currentScan : current scan ponts ;
  dir scanPoints_ref matchScan                   = matchScan   : matched scan points ;

  char   instFont               = 7 :2 = 9x15, 3 = 8x13, 4 = T10, 5 = T24, 6 = H10, 7 = H12, 8 = H18;
  char   menuFont               = 7 :2 = 9x15, 3 = 8x13, 4 = T10, 5 = T24, 6 = H10, 7 = H12, 8 = H18;
  char   wayFont                = 7 :2 = 9x15, 3 = 8x13, 4 = T10, 5 = T24, 6 = H10, 7 = H12, 8 = H18;
  float  znear                  = 2.0f    :near clipping plane (ft);
  float  fogNear                = 100.0   :near fog distance;
  double vis                    = 15000.0  :characteristic visibility (ft);
  double air                    = 100000.0 :characteristic height of atmosphere (ft);
  double starSize               = 5.0 :multiplier for star size;
  float  angle3Dspeed           = 0.2f :(0-1);
  float  animatePIPspeed        = 0.2f :;
  float  zoomMin                = -15 : ;
  float  zoomMax                = +15 : ;
  float  zoomMaxMap             = 30000000 : ;
  char   autoscaleNav           = 0  : ;
  double autoscaleNavMinX       = 0.0 : ;
  char   singleClickGreenCircle = 1 : ;

  int   showRunway         = 0    :show symbol (old);
  int   showSymbol         = 0    :show symbol (old);
  int   symbolFace         = 0 :0, 1, 2, 3;
  int   symbolBuilding     = -1 :building # where symbol is located at mck (-1 for none);
  int   fakeSymbolBuilding = -1 :building # where symbol is located at mck (-1 for none);
  float symbolH            = 2.5f*3.28f :height of symbol center;
  float symbolX            = 3.0f*3.28f :distance from edge of building to symbol center;
  float fsymbolH           = 3.5f*3.28f :height of symbol center;
  float fsymbolX           = 4.0f*3.28f :distance from edge of building to symbol center;

  char   trackingMode                 = 0 :mode of tracking;
  double sunAngle                     = -60 :-117.0 :intial sun longitude (deg-E);
  double starsAngle                   = 0 :(deg);
  Float  sunPosition[4]               = { 0.0f, 0.0f,-1.0f, 0.0 } : ;
  Float  sunAmbient[4]                = { 0.2f, 0.2f, 0.2f, 1.0 } : ;
  Float  sunDiffuse[4]                = { 1.0f, 1.0f, 1.0f, 1.0 } : ;
  Float  sunSpecular[4]               = { 0.0f, 0.0f, 0.0f, 1.0 } : ;
  Float  skyColor[4]                  = { 0.1f, 0.2f, 0.6f, 1.0 } : ;
  Float  waterColor[4]                = { 0.05f, 0.1f, 0.4f, 1.0 } : ;
  Float  navColor[4]                  = { 0.5f, 0.5f, 0.4f, 1.0 } :.4, .6, .15 ;
  Float  groundColor[4]               = { 0.4f, 0.4f, 0.3f, 1.0 } :.4, .6, .15 ;
  Float  shadowColor[4]               = { 0.0f, 0.0f, 0.0f, 0.3f } : ;
  Float  horizonColor[4]              = { 0.5f, 0.55f, 0.6f, 1.0 } : ;
  Float  videoSideColor[4]            = { 0.33f, 0.33f, 0.33f, 1.0 } : ;
  Float  obstacleGridColor[4]         = { 0.0f, 0.1f, 0.0f, 0.4f } : ;
  Float  obstacleGridObservedColor[4] = { 0.5f, 0.0f, 0.0f, 0.4f } : ;
  Float  gridIgnoreZoneColor[4]       = { 0.580f, 0.000f, 0.827f, 0.4f } : ;
  Float  evimapColorLow[4]            = { 0.0f, 0.0f, 1.0f, 1.0f } : ;
  Float  evimapColorHigh[4]           = { 0.0f, 1.0f, 0.0f, 1.0f } : ;
  float  OctomapMaxHeightForColor     = 50.0f:;
  double angStep                      = 0.05 :angle step for atmosphere rendering;
  double earthStep                    = 0.01 :angle step along Earth;

  float gridColor[4]  = { 0, 0, 0, 0.15f } : ;
  float gridx         = 50.0 :grid spacing (ft);
  int   gridmax       = 10 :number of grid lines per range off center;
  int   gridDraw10x   = 1 :draw larger grid;
  int   gridDraw100x  = 1 :draw even larger grid;
  int   showGridScale = 1 :draw scale length on grid for reference;
  int   overlayGridn  = 10 :number of repeated grid blocks for overlays off center;

  Float bodyAxesColor[4]    = { 1.0f, 0.4f, 0.0f, 1.0f } :body axes color;
  Float lgAxesColor[4]      = { 0.0f, 1.0f, 0.0f, 1.0f } :local geo axes color;
  Float omegaColor[4]       = { 0.0f, 0.0f, 1.0f, 1.0f } :angular rate color;
  Float angMomColor[4]      = { 0.6f, 0.0f, 1.0f, 1.0f } :angular momentum color;
  Float velColor[4]         = { 0.0f, 1.0f, 1.0f, 1.0f } :velocity color;
  Float trajColor[4]        = { 1.0f, 1.0f, 0.0f, 1.0f } :trajectory color;
  Float trajColor2[4]       = { 1.0f, 0.8f, 0.0f, 1.0f } :trajectory color;
  Float trajColorGps[4]     = { 0.5f, 0.5f, 1.0f, 1.0f } :trajectory color;
  Float trajColorGps2[4]    = { 0.1f, 0.1f, 1.0f, 1.0f } :trajectory color;
  Float cameraFOVColor1[4]  = { 0.0f, 0.4f, 0.0f, 1.0f } :color;
  Float cameraFOVColor2[4]  = { 0.0f, 0.9f, 0.0f, 1.0f } :color;
  Float trafficColor[4]     = { 0.85f, 0.85f, 1.0f, 1.0f } :color;
  Float hockeyPuckColor[4]  = { 0.4f, 1.0f, 0.4f, 0.4f } :color;
  Float pspFilamentColor[4] = { 0.0f, 0.0f, 0.0f, 1.0f } :filament color;
  float bodyAxesR[3]        = { 8.0f, 6.0f, 4.0f } :body axes lengths;
  float omegaScale          = 10.0f :angular vel vector scale, ft/(rad/sec);
  float angMomScale         = 2.5f :angular mom vector scale,  ft/(slug-ft2/sec);
  float velScale            = 1.0f :(s) velocity scale;
  float maxCameraDist       = 1000.0f :(ft) max distance to bother showing camera FOV;

  float runwayColor[4]         = { 0.3f, 0.3f, 0.1f, 1.0 } : ;
  float runwayMarkingsColor[4] = { 0.5f, 0.5f, 0.5f, 1.0 } : ;
  float runwayL                = 300.0   :runway length (ft);
  float runwayW                = 20.0    :runway width (ft);
  float stripeL                = 15.0    :stripe length (ft);
  float stripeW                = 1.0     :stripe width (ft);
  char  showAnnotations        = 1 : ;
  char  showBuildings          = 0 : ;
  float buildingPos[3][2]      = {{420,-145},{60,-150000},{-60,-150000}} : ;
  float buildingAngle[3]       = {65,30,0} :(deg);
  float buildingL              = 6.0f*3.28f :(ft);
  float buildingW              = 4.0f*3.28f :(ft);
  float buildingH              = 3.0f*3.28f :(ft);
  float buildingWinWidth       = 3.28f :3.28f :(ft);
  float buildingWinHeight      = 3.28f :3.28f :(ft);
  float buildingWinH           = 2.0f*3.28f :(ft);
  float cloudPos[3]            = {0,0,-500} :cloud position;
  float cloudSize              = 3000 :cloud size (ft*2);

  float hudLW[2] = {0.0,1.0} : ;
  float hudVideoLW[2] = {0.0,2.0} : ;
  float hudLW_PIP[2] = {0.0,1.0} : ;
  float hudVideoLW_PIP[2] = {0.0,2.0} : ;
  float hudColor[2][4] = {{ 0.0, 0.0, 0.0, 1.0 },{ 0.0, 1.0, 0.0, 1.0 }} : ;
  float hudAlternateSize = 2.0 : ;
  float hfov = 25.0     :hud field of view in degrees (it's square);
  float hrpx = 0.15f    :ref point for speed/altitude x;
  float hrpy = 0.05f    :ref point for speed/altitude y;
  float hudApX = 0.0f   :ref point for autopilot items x;
  float hudApY = 0.205f :ref point for autopilot items y;
  float hudCdiX = 0.0f  :ref point for CDI x;
  float hudCdiY = 0.0f  :ref point for CDI y;
  float hudCdiSize = 0.1f   :CDI size;
  float hudCdiGap  = 0.016f :CDI gap in middle;
  float hudCdiScaleVertical   = 10.0f  :(ft) full scale;
  float hudCdiScaleHorizontal = 50.0f  :(ft) full scale;
  char  hudBodyAxes           = 0 : ;
  char  showNorthOnMap        = 1 : ;
  char  seeThroughMap         = 1 :see through map if no overlay on PIP;
  float northOnMapSize        = 36.0 : ;

  Float treeColor[4] = { 0.4f, 0.7f, 0.3f, 1 } : ;
  Float blackColor[4] = { 0.15f, 0.15f, 0.15f, 1 } : ;
  Float buildingColor[12][4] = {{ 1, 1, 1, 1 },
  { 1, 0, 0, 1 },{ 0, 1, 0, 1 },{ 0, 0, 1, 1 },
  { 1, 1, 0, 1 },{ 1, 0, 1, 1 },{ 0, 1, 1, 1 },
  { .5f, .3f, 0, 1 },{ 1, .9f, .9f, 1 },{ 1, .6f, .2f, 1 },
  { .75f, .75f, .75f, 1},{ .3f, .35f, .54f, 1 }} : ;
  Float roofColor[4] = { 0.25f, 0.25f, 0.25f, 1 } : ;
  Float poleColor[4] = { 1.0f, 1.0f, 0.0f, 1 } : ;

  string efile = "earth.bmp" :file name of tree texture file;
  int ewidth = 0 :width of texture;
  int eheight = 0 :height of texture;
  int ecomponents = 0 :number of components of texture;

  string gfile = "g128.rgb\0                                  " :file name of texture file;
  int gwidth = 0 :width of texture;
  int gheight = 0 :height of texture;
  int gcomponents = 0 :number of components of texture;

  string tfile = "tree.rgb\0                                  " :file name of tree texture file;
  int twidth = 0 :width of texture;
  int theight = 0 :height of texture;
  int tcomponents = 0 :number of components of texture;

  string cfile = "cloud2.rgba\0                               " :file name of cloud texture file;
  int cwidth = 0 :width of texture;
  int cheight = 0 :height of texture;
  int ccomponents = 0 :number of components of texture;

  string bfile = "target4.bmp\0           " :file name of target texture file;
  string ffile = "targetfake.bmp\0        " : file name of fake target ;
  string tpfile= "testpattern.bmp\0       " : file name of video test pattern ;
  string rooffile       = "roof.bmp\0                       " : file name of roof texture ;
  string wallfile       = "roof.bmp\0                       " : file name of wall texture ;
  string waterfile      = "water.bmp\0                      " : file name of water texture;
  float waterlen        = 100.0f :(ft) length covered by water texture;
  string treelinefile   = "treeline.bmp\0                   " : file name of treeline texture;
  float treelinelen     = 100.0f :(ft) length covered by treeline texture file;

  float  minWaySize                  = 20.0f :min radius of waypoint (pixels);
  float  swLabel[3]                  = {0,0,0} :location of selected waypoint label (ft);
  float  pickTol                     = 30 :tolerance to pick things (pixels);
  double minClickTime                = 0.2 :(sec) used to be 0.5;
  double doubleClickTime             = 1.0 :(sec);
  double timeLabelStep               = 60.0 :(sec);
  double planUpdateStep              = 0.2 :update dt of plan preview;
  double planStep                    = 0.1 :step of trajectory plan plot (sec);
  double futureTime                  = 3 :lookahead time for future command (sec);
  double futureTimeMult              = 1 :lookahead time for future command speed multiplier;
  double trajMax                     = 5*60  :maximum traj propogation time (sec);
  double lastClickSelectTime         = -1 :(sec);
  float  trHeight                    = 20 :height of tracking result plot;
  float  trSize                      = 10 :characteristic size for the tracking result triangle;
  Float  wayNavColor[4]              = {0,0,1,1} :nav waypoint color;
  Float  wayDatumColor[4]            = {0,0,0,1} :nav waypoint color;
  Float  wayGpsrefColor[4]           = {1,1,1,1} :nav waypoint color;
  Float  wayComColor[4]              = {0.4f,0.4f,0.2f,1} :command color;
  Float  wayFutureComColor[4]        = {0.7f,0.7f,0.35f,1} :future command color;
  Float  mouseOverWayColor[4]        = {1,1,1,1} :selected waypoint color;
  Float  selectedWayColor[4]         = {1,0.65f,1,1} :selected waypoint color;
  Float  selectedWayTextColor[4]     = {1,0.5f,1,1} :selected waypoint color;
  Float  planColor[4]                = {.4f,0,.4f,1} :flight plan color;
  Float  geofenceColor[4]            = {1.0f,0.4f,0.4f,1} :geofence color;
  Float  autopilotDelsColor[4]       = {1,.67f,0,1} :autopilot cmds color;
  float  waypointThickness           = 0.1f :fraction of radius, max 1;
  float  planWidth                   = 0.05f :fraction of radius (half width of line);
  float  planLineWidth               = 3 :line width;
  float  gcsLineWidth                = 1 :line width;
  float  bigRedXLineWidth            = 3 :line width;
  char   drawApproachSymbology       = 1 : ;
  double approachFanSize             = 0.075 :size of approach fan;
  double dashLength                  = 20       :dash length on missed approach line;
  Float  approachColor[4]            = {1,1,1,0.2f} :approach fan color;
  Float  approachLeftColor[4]        = {1,0.7f,1,0.3f} :approach fan color;
  Float  approachRightColor[4]       = {0.3f,0,0.3f,0.3f} :approach fan color;
  Float  runwaySymbolColor[4]        = {0,0,0,1} :runway symbol color;
  Float  missedApproachColor[4]      = {0,0,0,1} :missed approach color;
  Float  missedApproachColor2[4]     = {1,1,1,1} :missed approach color;
  Float  extTrajColor[4]             = {.1f,1,1.0f,1.0f} :external flight plan color;
  Float  formationColor[4]           = {0.7f,0.7f,1.0f,0.5f} : ;
  Float  instTextColor[4]            = {0,1.0f,0,1} :extra info color;
  Float  instTextCautionColor[4]     = {1,1,0,1} :extra info color;
  Float  instTextWarningColor[4]     = {1,0.2f,0.2f,1} :extra info color;
  Float  menuTextColor[4]            = {1,1,1,1} :menu text color;
  Float  checklistColor[4]           = {1,1.0f,1,1} :checklist text color;
  Float  instBackColor[4]            = {0,0,0,0.4f} :extra info background color;
  Float  virtualJoystickColor[4]     = {0,1,0,0.33f} :virtual joystick;
  Float  virtualJoystickOverColor[4] = {0,1,0,1} :virtual joystick;
  Float  wayBoxBackColor[4]          = {0,0,0,0.4f} :extra info background color;
  Float  sampledTrajsColor[4]        = {.8f,0,.8f,0.2f} : ;

  float instTextX  = 2 :location of instrument text;
  float instTextY  = 2 :location of instrument text;
  float instTextLH = 4 :extra line height of instrument text;
  float instTextLW = 2 :width of instrument text line (joystick);
  float instBoxE   = 3 :extra pixels for background box;
  float gridLW[2]  = {1,2} :grid line widths (zooming or not);

  int   speedUnits               = SPEED_FPS :0   = fps, 1 = knots, 2 = kph, 3 = mph, 4 = m/s;
  int   distanceUnits            = DISTANCE_FT :0 = ft,  1 = m,     2 = nm,  3 = km;
  int   posUnits                 = POS_FEET :0    = ft,  1 = latlong;
  char  showWaypointsMSL         = 0 :waypoint text MSL;
  char  showWaypointNumbers      = 0 :show waypoint number in block;
  char  enableGCSSelect          = 0 :allow picking GCS;
  char  showNameText             = 0 :show name of vehicle of GCS text block;
  char  showRmtCnsl              = 1 :show remote console on scene window;
  char  drawLineToText           = 0 :draw line between vehicle and GCS text;
  char  showJoystick             = 1 :show joystick inputs with GCS text;
  char  showMarkOnClickWithRange = 1 :include range from datum on green circle click;
  char  showWaypointDistance     = 0 :include distance in waypoint text block;
  char  showBldgRoofTexture      = 0 :show building roof texture;
  char  showBldgWallTexture      = 0 :show building roof texture;
  char  showWaterTexture         = 0 :show water texture;
  char  showGpsref               = 1 :show gps ref location;
  char  showPPTarget             = 0 :show pointpos facing camera frame;
  float pptargetR                = 1 : target radius;
  float minPptargetSize          = 5 : min radius;
  float menuTextLW               = 2.0 :width of menu text line;
  float menuW                    = 46 :width of view menu items;
  float menuH                    = 8 :extra height of view menu items;
  float menuX                    = 2  :pos of menu items;
  float menuY                    = 2  :pos of menu items;
  float viewMenuX                = 1 :order of menu;
  float wayMenuX                 = 2 :order of menu;
  float visMenuX                 = 3 :order of menu;
  float typeMenuX                = 4 :order of menu;
  float velMenuX                 = 5 :order of menu;
  float altMenuX                 = 6 :order of menu;
  float headMenuX                = 7 :order of menu;
  float modeMenuX                = 8 :order of menu;
  float customMenuX              = 9 :order of menu;
  char  menuKeys                 = 1 :use keys to move around menu;
  int   deadbandMouse            = 10 :pixels of motion deadband for mouse view changes;
  int   zoomWide                 = 40 :pixels of zoom bar width on right side;
  float wayTextX                 = 2 :location of waypoint text;
  float wayTextY                 = 2 : ;
  float wayTextLH                = 4 :space betwen lines of waypoint text;
  float panelWidth               = 300 :width of panel;
  float panelUp                  = 20  :panel up from bottom;
  float joyX                     = 0.015f : ;
  float joyY                     = 0.015f : ;
  float joySize                  = 0.25f : ;
  float joyLW                    = 5 : ;
  float joySS                    = 0.01f : ;

  double dtTraj            = 0.02 :(sec) min dt for storing trajectory points;
  double dtTraj_nav        = 0.2  :(sec) min dt for storing trajectory points;
  double dtTraj_gps        = 0.2  :(sec) min dt for storing trajectory points;
  int    ntpoints          = 0    :number of stored trajectory points;
  int    ntpoints_nav[4]   = {0,0,0,0}   :number of stored trajectory points;
  int    ntpoints_other[4] = {0,0,0,0}   :number of stored trajectory points;
  int    ntpoints_gps[4]   = {0,0,0,0}   :number of stored trajectory points;

  char showRealScene                     = 0 :draw McKenna villiage;
  char drawComplexScene                  = 0 :draw the Buckbee Building hangar for FirstResponder ;
  char allowClickingWaypointBox          = 1 :allow clicking on waypoint box;
  char allowWaySelectingWithNoShiftMouse = 1 :allow selecting a waypoint without shifting on the left click;
  char extraQuad                         = 0 :draw extra quad for some graphics cards;
  char forceWidthDivisibleBy4            = 1 :for sceneCapture to work properly;
  char orient                            = 0 :flag for mouse orientation;
  char move                              = 0 :flag for mouse waypoint move;
  char movePIP                           = 0 :flag for moving PIP;
  int  holdMouseOverWay                  = -1 : ;
  char joyLeft                           = 0 : ;
  char joyRight                          = 0 : ;
  int  xorient                           = -1 :use mouse for orientation;
  int  yorient                           = -1 :use mouse for orientation;

  int stars_dl        = 0 :display list;
  int grid_dl         = 0 :display list;
  int grass_dl        = 0 :display list;
  int tree_dl         = 0 :display list;
  int treeNoTex_dl    = 0 :display list;
  int building_dl     = 0 :display list;
  int buildingSym_dl  = 0 :display list;
  int fakeSym_dl      = 0 :display list;
  int realScene_dl    = 0 :display list;
  int wdb_dl          = 0 :world database display list;
  int cloud_dl        = 0 :display list;
  int runway_dl       = 0 :display list;
  int earth_dl        = 0 :display list;
  int circle_dl       = 0 :display list;
  int waypoint_dl     = 0 :display list;
  int waypointH_dl    = 0 :display list;
  int waypointH2_dl   = 0 :display list;
  int waypointP_dl    = 0 :display list;
  int leader_dl       = 0 :display list;
  int datum_dl        = 0 :display list;
  int traffic_dl      = 0 :display list;
  int complexScene_dl = 0 :display list;
  int collAvoidR_dl   = 0 :display list;

  int hud_horizon_dl     = 0 :display list;
  int hud_ladder_dl      = 0 :display list;
  int hud_alternate_dl   = 0 :display list;
  int hud_reference_dl   = 0 :display list;
  int hud_fp_dl          = 0 :display list;
  int hud_bankscale_dl   = 0 :display list;
  int hud_scales_dl      = 0 :display list;
  int hud_bank_dl        = 0 :display list;
  int hud_fd_dl          = 0 :display list;
  int hud_sb_dl          = 0 :display list;
  int northOnMap_dl      = 0 :display list;
  int cornerMarker_dl    = 0 :display list;
  int sphereObstacle_dl  = 0 :display list;
  int genericObstacle_dl = 0:display list for keeyryun;

  double runwayLat                = 33.47415    :middle of the end of runway;
  double runwayLon                = -84.0835    :middle of end of runway;
  double runwayAlt                = 765.0    :Altitude of Runway;
  float  runwayCrs                = 120.0    : Orientation of Runway;
  float  runwayCornerMarkColor[4] = { 1.0f, 0.0f, 0.0f, 1.0 } : ;
  float  runwayCornerMarkHeight   = 2.0 : ;
  float  runwayCornerMarkRadius   = 2.0 : ;

  float pipSize      = 0.33f   :fraction of height;
  float pipRatio     = 4.0f/3  :width/height;
  int   pipOffsetX   = 15    :distance from right;
  int   pipOffsetY   = 15    :distance from bottom;
  int   pipE         = 5     :pix around edge;
  int   pipResizeBox = 40  :pixels of resize box;

  Float  sphereObstacleColor[4]             = { 0.7f, 0.7f, 1.0f, 1.0 } : RGBA color array;
  Float  sphereObstacleColorAlt[4]          = { 0.0f, 0.0f, 0.3f, 1.0 } : RGBA color array;
  Float  sphereObstacleColorConverged[4]    = { .8f, 0.0f, 0.0f, 1.0 } : RGBA color array;
  Float  sphereObstacleColorConvergedAlt[4] = { .2f, 0.0f, 0.0f, 1.0 } : RGBA color array;
  Float  sphereCovColor[4]                  = { 0.7f, 0.7f, 1.0f, 0.5 } : RGBA color array;
  Float  worldPointColor[4]                 = { 0.7f, 1.0f, 0.7f, 1.0 } : RGBA color array;
  Float  worldPointColorAlt[4]              = { 0.0f, 0.3f, 0.0f, 1.0 } : RGBA color array;
  float  sphereObstacleRadius               = 0.2f: base obstacle radius ;
  float  mapfpObstacleRadius                = 15: scale factor for mapfp sphere radius;
  float  mapfpObstacleMaxScaleAlt           = 20: Altitude at which sphere reaches max radius;
  float  impfObstacleRadius                 = 20: scale factor for impf sphere radius;
  int    sphereObstacleSlices               = 10 : ;
  int    sphereObstacleStacks               = 10 : ;
  float  worldPointSize                     = 20 : ;
  int    mapfpObsThresh                     = 200 : ;
  int    numberOfObstacles                  = 0  : number of obstacles (max 8);
  Float  scanColor[4]                       = {0.2f, 1.0f, 0.2f, 0.3f} : ;
  Float  scanColorGroup1[4]                 = {0.2f, .2f, 1.0f, 0.3f} : ;
  Float  scanColorGroup2[4]                 = {1.0f, 0.2f, 0.2f, 0.3f} : ;
  Float  slamVelColor[4]                    = {0.0f, 1.0f, 0.0f, 1.0f} : ;
  Float  scanSimColor[4]                    = {0.2f, 0.6f, 0.3f, 0.3f} : ;
  Float  scanPointColor1[4]                 = {1.0f, 1.0f, 1.0f, 1.0f} : ;
  Float  scanPointColor2[4]                 = {0.2f, 1.0f, 1.0f, 1.0f} : ;
  Float  scanPointColor3[4]                 = {0.0f, 1.0f, 0.0f, 1.0f} : ;
  Float  scanWallColor[4]                   = {0.5f, 0.5f, 1.0f, 1.0f} : ;
  Float  scanDoorColor[4]                   = {1.0f, 1.0f, 0.0f, 1.0f} : ;
  Float  ellipseColor[4]                    = {0.0f, 0.3f, 1.0f, 0.2f} : ;
  Float  guidanceColor[4]                   = {0.0f, 0.6f, 1.0f, 0.4f} : ;
  float  scaleGuidance                      = 1 :scale guidance distance draw ;
  char   guidanceSensor                     = 0 :0-use obstacle distance for draw, 1-ultrasonic;
  float  guidanceOutofRange                 = 5.6f :distance to stop drawing guidance measurements(in ft);
  float  scanPointSize                      = 4.0f : ;
  float  dataLineWidth                      = 4.0f : ;
  float  scanPointAlt                       = -5.0f : Height to draw scan points (ft);
  float  maxScanRangeShown                  = 1000 : ft, max range shown in sim ;
  double messageHangTime                    = 0.5 :(sec) time to keep message up;
  double messageFadeTime                    = 3   :(sec) time to fade message;
  float  messageY                           = 0.8f :ratio from bottom of screen;
  float  checklistY                         = 0.65f :ratio from bottom of screen;
  char   drawLaserHighlight                 = 0 : ;
  char   showScanLayer[4]                   = {1,1,1,1} : ;
  char   showScanMaxRange                   = 0 :show max range if no return;
  char   showBothTraj                       = 0 :show both nav and truth trace at once;
  char   showAllTraj                        = 1 :show trace from all GCSs;
  char   showRabbit                         = 0 :2 = fixed future time;
  char   showHockeyPuck                     = 1 : ;
  char   resetViewWhenSwitchToFollow        = 1 : ;
  int    fontHeight[9]                      = {0,0,10,9,7,17,8,9,14} : ;
  Float  masAreaColor[4]                    = {0.0f, 1.0f, 1.0f, 1.0f} : map and search area ;
  Float  watermarkColor[4]                  = {1.0f, 1.0f, 0.5f, 0.2f} : ;
  int    watermarkPos[2]                    = {10,10} : ;
  int    watermarkFont                      = 8 :2 = 9x15, 3 = 8x13, 4 = T10, 5 = T24, 6 = H10, 7 = H12, 8 = H18;
  string watermarkText                      = "Georgia Tech UAVRF\0                             " : ;
  uchar  gcsOrder[4]                        = {0,1,2,3} :order of GCS instances on display;
} sceneGlobal;

%Dir scanPoints_ref {
    float   multiplier        = 0 : Scale factor to convert double (x,y) points (ft) to +/- 32767;
    float   basePos[2]        = {0,0} : Vehicle (x,y) position (ft);
    generic short int x [682] = {0} : Scan point x positions;
    generic short int y [682] = {0} : Scan point y positions;
} keyScan, currentScan, matchScan;

%Dir gtarDesk_ref {
  int    show             = 0  : ;
  int    dl               = 0 :display list;
  string filename         = "gtar_stick.bmp" :name of bmp file;
  float  location[3]      = { 0.0 , 0.0 , 0.0 } :picture location in local frame;
  float  angle            = 0  :orientation angle in the sim;
  float  deskColor[4]     = {.3f,.2f,.2f,1} : ;
  float  boxColor[4]      = {1,1,1,1} : ;
  float  deskLength       = 60.0f/12 :(ft);
  float  deskHeight       = 30.0f/12 :(ft);
  float  deskDepth        = 30.0f/12 :(ft);
  float  boxLocation[2]   = {0.7f,2} :(ft);
  float  boxAngle         = 0 :(deg);
  float  boxLength        = 11.0f/12 :(ft);
  float  boxWidth         = 8.5f/12 :(ft);
  float  stickLocation[2] = {0.3f,0.2f} :(ft);
  float  stickAngle       = 30 :(deg);
  float  stickSize        = 0.213f :(ft);
} gtarDesk;

%Dir gtarswitchpost_ref {
  int    show             = 0                         : ;
  int    dl               = 0                         :display list;
  string filename         = "gtarswitch.bmp"          :name of bmp file;
  float  location[3]      = { 25.0f , 3.95f , 0.0f }       :picture location in local frame;
  float  angle            = 0                         :orientation angle in the sim;
  float  postColor[4]     = {.3f,.2f,.2f,1}            : ;
  float  boxColor[4]      = {1,1,1,1}                : ;
  float  postLength       = 1                 :(ft);
  float  postHeight       = 4                 :(ft);
  float  postDepth        = 1                 :(ft);
  float  boxLocation[2]   = {0,0}                  :(ft);
  float  boxAngle         = 0                        :(deg);
  float  boxLength        = 0                 :(ft);
  float  boxWidth         = 0                  :(ft);
  float  stickLocation[2] = {.5f,0}          :(ft);
  float  stickAngle       = 0                       :(deg);
  float  stickSize        = 0.4f                   :(ft);
} gtarswitchpost;

%Dir gtarRover_ref {
  int    show             = 0                         : ;
  int    dl               = 0                         :display list;
  string filename         = "GTAR_ROVER1.bmp                                  " :name of bmp file;
  float  location[3]      = { 1.2f,2.0f,-2.5f }       :picture location in local frame;
  float  angle            = 0                         :orientation angle in the sim;
  float  roverLocation[2] = {0.0f,0.0f}          :(ft);
  float  roverAngle       = 0                       :(deg);
  float  roverSize        = 0.313f                   :(ft);
  float  roverScale[3]    = {5.0f,5.0f,1.0f} :;
} gtarRover, gtarAHS2, gtarAHS3, gtarAHS4;

%Dir sceneRoombaTargets_ref {
  int   show     = 0                         : ;
  int   dl       = 0                      :display list;
  float radius   = 0.7f                   :(ft);
  float height   = 0.2f                   :(ft);
  float color[4] = { 0.7f, 0.7f, 0.7f, 1.0f } : ;
} sceneRoombaTargets;

%Dir sceneMbzirc_ref {
  int show           = 0  : ;
  int smallTarget_dl = 0 : ;
  int largeTarget_dl = 0 : ;
  int smallStand_dl  = 0 : ;
  int largeStand_dl  = 0 : ;

  float standBaseRadius     = 0.410104987f :250mm/2 0.410104987f;
  
  float standColor[4]       =     {0.412f, 0.412f, 0.412f,1.0f} :grey ;
  
  float largeStandBaseWidth = 0.82021f : ;
 } sceneMbzirc;

%Dir sceneGtarPylns_ref {
  int   show     = 0                         : ;
  int   dl       = 0                      :display list;
  float radius   = 0.3f                   :(ft);
  float height   = 3.0f                   :(ft);
  float color[4] = { 0.7f, 0.2f, 0.2f, 1.0f } : ;
} sceneGtarPylns;

%Dir randPolygons_ref {
  int    randTestInit       = 0                     : test auto starts after init ;
  int    show               = 0                     : 1 display,                0 hide;
  int    randTestIsRunning  = 0                     : ;
  double randTestNextUpdate = 0                     : ;
  double randTestdt         = 5                     : seconds ;
  float  randRadius         = 0.3f                  :radius of circle circumscribed about polygon;
  int    numPolygons        = 100                   :Number of random polygons, max is 500;
  double simDummyTime       = 0                     :copy of sim.time;
  double updateRate         = 1000                  :(ms)time between movement;
  float  rangeFactor        = 1.15f                 :factor to adjust spread of polygons;
  float  range              = 4                     :max distance from datum for polygon to appear;
  int    randPolygons_dl    = 0                     :display list;
  float  location[3]        = { 3.0 , -4.0 , -0.1f} :Polygon center location in local frame;
  float  color[4]           = {.3f,.2f,.2f,1}       :color of polygons ;
  double updateTime[2]      = { 0.0 , 0.0}          :[0] is negative,           [1] is positive;
  float  randomSeed[2][500] = { 0 }                 :random locations;
  float  randomRots[500]    = { 0 }                 : random rotation angles;
} randPolygons;

%Dir pictureObstacle_ref {
  int    show        = 0                         : 1 display, 0 hide;
  int    obstacle_dl = 0                         : opengl display list;
  string filename    = "sinaps_banner.bmp": name of bmp file;
  float  width       = 15                        : width in ft;
  float  height      = 5                         : height in ft;
  float  location[3] = { 0.0 , 0.0 , 0.0 }       : picture location in local frame (lower left corner);
  float  angle       = 0                         : orientation angle in the sim;
} pictureObstacle;


%Dir bannerObstacle_ref {
  int   show        = 0                          : 1 display, 0 hide;
  int   dark_dl     = 0                          : display list for dark checkers on banner obstacle;
  int   light_dl    = 0                          : display list for light checkers on banner obstacle;
  float width       = 15                         : width in ft;
  float height      = 5                         : height in ft;
  float checkerW    = 2.5f                       : width of individual checker box;
  float checkerH    = 2.5f                       : height of individual checker box;
  float color1[4]   = { 1.0f, 1.0f, 1.0f, 1.0f } : RGBA (white default);
  float color2[4]   = { 0.0f, 0.0f, 0.0f, 1.0f } : RGBA (black default);
  float location[3] = { 0.0 , 0.0 , 0.0 }        : banner location in local frame (lower left corner);
  float angle       = 0                          : orientation angle in the scene;
} bannerObstacle;

%Dir gtarAHS_ref {
  int   show        = 0                          : 1 display, 0 hide;
  int   dark_dl     = 0                          : display list for dark checkers on banner obstacle;
  int   light_dl    = 0                          : display list for light checkers on banner obstacle;
  float width       = 100                         : width in ft;
  float height      = 35                         : height in ft;
  float thickness   = 3.0f/12                    : thickness in ft;
  float checkerW    = 2.5f                       : width of individual checker box;
  float checkerH    = 2.5f                       : height of individual checker box;
  float color1[4]   = { 1.0f, 1.0f, 1.0f, 1.0f } : RGBA (white default);
  float color2[4]   = { 255.0f, 255.0f, 0.0f, 1.0f } : RGBA (black default);
  float location[3] = { 0.0 , 0.0 , 0.0 }        : banner location in local frame (lower left corner);
  float angle       = 0                          : orientation angle in the scene;
} gtarAHS;

%define SCENE_MESSAGEMAXLENGTH 60

%Dir scene_ref {
  string name = "Scene Window 0\0                         " :name of window;

  char  showTruth              = 1 :show truth heli;
  char  showGCS                = 1 :show GCS information;
  char  showGrid               = 1 :show grid in scene;
  char  showTrack              = 0 :show tracking for image processor;
  char  showMag                = 0 :show magnetic field;
  char  showBodyAxes           = 0 :show body axes;
  char  showLgAxes             = 0 :show local geo axes;
  char  showVel                = 0 :show linear velocity;
  char  showOmega              = 0 :show angular velocity;
  char  showAngMom             = 0 :show angular momentum;
  char  showTraj               = 1 :show trajectory trace;
  char  showGpsTraj            = 0 :show trajectory trace of gps;
  char  showLabels             = 0 :show labels on vectors;
  char  showRawGps             = 0 :show raw GPS data;
  char  showSVInfo             = 1 :show SV info;
  char  showThreats            = 0 :show the threats;
  char  showCloud              = 0 :show cloud (texture required);
  char  showNavIP              = 1 :show navip data;
  char  showMapFP              = 0 :show mapfp data;
  char  show3dCov              = 0 :show 2D error ellipse;
  char  showMapLssmFP          = 0 :show lssm fp data;
  char  showImpf               = 0 :show impf data;
  char  showWorldPoints        = 0 :show world point data;
  char  showSafetyEllipsoid    = 0 :show safety ellipsoid;
  char  howDrawObs             = 0 :what data to use for position of safety ellipsoid, 0 - onboard extman data, 1 - mavlink;
  char  showVisionFormation    = 1 :show vision formation data;
  char  showScan               = 0 :show laser scan (1=show everything 2=ignore out of range) ;
  char  showScanPoints         = 0 :show laser scan points;
  char  showSLAM               = 0 :show SLAM map;
  char  showWDB                = 1 :show WDB;
  char  showGraph              = 0 :show igraph map;
  char  showGraph2             = 0 :show igraph map2;
  char  showGraph3             = 0 :show igraph map3;
  char  showORScan             = 1 :show out of range points;
  char  showKeyPts             = 0 :show key laser scan points;
  char  showCurrentPts         = 0 :show current laser scan points;
  char  showMatchedPts         = 0 :show matched laser scan points;
  char  showSlamData           = 0 :show wall and door from laser scan;
  char  show2dCov              = 0 :show 2D error ellipse;
  char  showDjiGuidance        = 0 :show dji guidance output;
  char  showAnnotationFP       = 0 :show annotations to texture from FP image processing;
  char  showAnnotationSlung    = 0 :show annotations to texture from Slung load image processing;
  char  showAnnotationBoxes    = 0 :show annotations to texture from boxes message;
  char  hudAlternate           = 1 :mode of hud;
  char  showMessages           = 1 :show hanging messages;
  char  showChecklist          = 1 :show any active checklist items;
  char  showMarkOnClick        = 0 :show lat/long on click;
  float scale2dCov             = 1.0f :scale factor for ellipse;
  int   showLaser              = 0: point lidar model (not scanner);
  char  showPspFilament        = 1 :show psp filament;
  char  showStars              = 1 :show stars;
  char  showGrass              = 0 :show generic grass texture;
  char  showEvimap             = 0 :show terrain height map (0=off 1=show GCS copy 2=show OB copy 3=show OB2 copy);
  char  showWatermark          = 0 :show watermark (not on PIP);
  char  showBenchLOS           = 0 :show benchmark LOS grid;
  char  showTraffic            = 1 :show traffic (ADS-B);
  char  showRadar              = 1 :show radar contacts;
  char  showBoxes              = 1 :show ip bounding boxes;
  char  showFrameRate          = 1 :show frame rate;
  char  showMBZIRC             = 0 :show mbzirc package(laser) location;
  char  showTrueDeckRefPts     = 0 : ;
  char  showOb2PredDeckRefPts  = 0 : ;
  char  showGcsPredDeckLandPts = 0 : ;

  char allowRightClickMenu = 1 :allow menu at all;
  char videoModeDerived  = 0 :show captured video;
  char viewMenuOpen = 0       :state of menu;
  char viewMenuMouseOver = -1 : ;
  char visMenuOpen = 0       :state of menu;
  char visMenuMouseOver = -1 : ;
  char wayMenuOpen = 0       :state of menu;
  char wayMenuMouseOver = -1 : ;
  char typeMenuOpen = 0       :state of menu;
  char typeMenuMouseOver = -1 : ;
  char velMenuOpen = 0       :state of menu;
  char velMenuMouseOver = -1 : ;
  char altMenuOpen = 0       :state of menu;
  char altMenuMouseOver = -1 : ;
  char headMenuOpen = 0       :state of menu;
  char headMenuMouseOver = -1 : ;
  char modeMenuOpen = 0       :state of menu;
  char modeMenuMouseOver = -1 : ;
  char customMenuOpen = 0       :state of menu;
  char customMenuMouseOver = -1 : ;
  char joyLeftMouseOver = 0 : ;
  char joyRightMouseOver = 0 : ;
  char showingChecklist = 0 :flag to indicate if checklist is visible;
  float checklistBox[2][2] = {{0,0},{0,0}} : ;
  float textBox[4][2][2] = {{{0,0},{0,0}},{{0,0},{0,0}},{{0,0},{0,0}},{{0,0},{0,0}}} : ;
  float rasterPosVehicle[4][4] = {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0}} : ;
  char  checklistMouseOver     = 0 : ;
  char  textMouseOver[4]       = {0,0,0,0} : ;
  char  noInsert               = 0 : ;
  char  waySelectMode          = 0 : ;
  char  wayInsertMode          = 0 : ;
  char  lookat                 = LOOKAT_BOTH :select GCS, truth, or both;
  char  redraw                 = 1           :initialize window;

  float fpLineLength = .02f    :line length for feature point annotation;

  char   usedKeys     = 0  :used keys flag;
  int    mouseOverWay = -1 :mouse over waypoint (-1 = none);
  char   mouseOverPIP = 0 :mouse over PIP;
  double altStep      = 2.5  :altitude step (ft);
  double posStep      = 10.0 :position step (ft);
  double angStep      = 5.0  :angle step (deg);
  double velStep      = 1.0  :velocity step (ft/sec);
  double accStep      = 1.0  :acceleration step (ft/sec2);
  double futureTime   = 3 :lookahead time for future command (sec);

  float fovy = 30.0     :vertical field of view (deg) at standard zoom;

  int hudw = 150        :width of hud;
  int hudh = 150        :height of hud;

  int fullScreen = 0    :fullscreen mode flag;

  float  eyePhi      = 0.0 :eye roll angle (rad);
  float  eyeTheta    = 0.0 :eye pitch angle;
  float  eyePsi      = 0.0 :eye yaw angle;
  double eyeLat      = 0.0 :eye latitude (deg-N);
  double eyeLon      = 0.0 :eye longitude (deg-E);
  double eyeAlt      = 0.0 :eye altitude (ft);
  int    yzoom       = -1 :use mouse for zoom;
  float  vec[3]      = {1,0,0} :vector mouse pointing at (in view frame);
  float  animatePIP  = 0.0 :;
  double cosDatumLat = 1         :cosine of datum latitude;

  int    open           = 0   :open flag;
  int    visibility     = 0 :visibility flag;
  int    winw           = 720 :width of window;
  int    winh           = 540 :height of window;
  int    oldw           = 400 :width of window prior to fullscreen;
  int    oldh           = 300 :height of window prior to fullscreen;
  int    x              = 412 :initial location of window;
  int    y              = 224*0 :initial location of window;
  int    mx             = 0   :mouse location;
  int    my             = 0   :mouse location;
  int    modifiers      = 0   :shift and control keys;
  int    win            = 0   :window id #;
  char   show3D         = 0   :derived;
  char   pick           = 0   :pick a waypoint next time around;
  char   pickPlant      = 0   : plant poles on pick;
  int    gm_dl          = 0 :google map display list;
  int    oldzoom        = -1 :google map ;
  char   oldmapType     = -1 : ;
  double oldlat         = 300.0 :(deg) google map;
  double oldlon         = 300.0 :(deg) google map;
  double gmLat          = 0 :(deg) map lat;
  double gmLon          = 0 :(deg) map long;
  double gmZoom         = 0 : map zoom;
  int    map_higherZoom = 0 :finding zoom level in cache;
  int    map_tryHigher  = 0  :finding zoom level in cache;
  int    usedSRTM       = 0 :used terrain data for overlays/google maps;

  string messageText0 = "123456789012345678901234567890123456789012345678901234567890" : ;
  string messageText1 = "123456789012345678901234567890123456789012345678901234567890" : ;
  string messageText2 = "123456789012345678901234567890123456789012345678901234567890" : ;
  string messageText3 = "123456789012345678901234567890123456789012345678901234567890" : ;
  double messageTime0 = -100 :(sec) time to keep message up until;
  double messageTime1 = -100 :(sec) time to keep message up until;
  double messageTime2 = -100 :(sec) time to keep message up until;
  double messageTime3 = -100 :(sec) time to keep message up until;

  uint    gtexture                    = 0 :texture number;
  uint    ttexture                    = 0 :texture number;
  uint    etexture                    = 0 :texture number;
  uint    ctexture                    = 0 :texture number;
  uint    btexture                    = 0 :texture number;
  uint    ftexture                    = 0 :texture number;
  uint    tptexture                   = 0 :texture number;
  uint    rooftexture                 = 0 :texture number;
  uint    walltexture                 = 0 :texture number;
  uint    watertexture                = 0 :texture number;
  uint    treelinetexture             = 0 :texture number;
  uint    vtexture                    = 0 :texture number;
  uchar   vtextureFrame               = 0 :texture number counter;
  uint    potexture                   = 0 :texture number;
  uint    gdtexture                   = 0 :texture number;
  uint    gptexture                   = 0 :texture number;
  uint    gmtexture[9]                = {0,0,0,0,0,0,0,0,0} :texture number;
  uint    otexture[10]                = {0,0,0,0,0,0,0,0,0,0} :SCENE_NUMBEROFOVERLAYS;
  uint    slamtexture                 = 0 :texture number;
  uint    grtexture                   = 0 :texture number;
  uint    gr2texture                  = 0 :texture number;
  uint    wvtexture                   = 0 :texture number;
  uint    wv2texture                  = 0 :texture number;
  uint    ahstexture                  = 0 :texture number;
  uint    ahstexture2                 = 0 :texture number;
  uint    ahstexture3                 = 0 :texture number;
  uint    trucktexture                = 0 :texture number;
  generic char waySelected[MAN_NMANS] = {0} : ;
  char    openglGrabber               = 0 :capturing images for opengl frame grabber;
  uint    grabberAllocatedSize        = 0 :opengl grabber;
  voidptr grabberData                 = 0 :opengl grabber;
} scene0;

%Dir scene_ref {
  string name = "Scene Window 1\0                         " :name of window;

  int winw = 400 :width of window;
  int winh = 300 :height of window;
  int x = 412  :initial location of window;
  int y = 360+0*523  :initial location of window;
} scene1;

%Dir scene_ref {
  string name = "Scene Window 2\0                         " :name of window;

  int winw = 400 :width of window;
  int winh = 300 :height of window;
  int x = 412  :initial location of window;
  int y = 190  :initial location of window;
} scene2;

%Dir scene_ref {
} scenePIP;

%Dir gcsScene_ref {
  char  viewMode          = VIEW_CHASE :current view mode selected;
  char  showPIP           = 0 :show picture in picture;
  char  showTex           = 0 :show textures;
  char  showMenu          = 0 :show menus;
  char  showGCStext       = 1 :show GCS extra text information;
  char  showPanel         = 1 :show panel;
  char  showCameraFOV     = 0 :show camera FOV;
  char  virtualJoystick   = 1 :show/allow joystick controls (not on PIP);
  char  showPlan          = 0 :0 = off, 1 = all, 2 = waypoints only;
  char  videoMode         = 0 :show captured video if in camera view;
  char  show3Dmap         = 0 :show 3D map mode;
  char  mapUpMode         = MAPUP_CONST : ;
  char  showAutopilotDels = 3 :1 = show if autopilot off, 2 = show if virtual joysticks on, 3 = show always;
  char  showGeofence      = 0 :showGeofence (=1 if on, =2 always);
  float mapUpAngle        = 0 : ;
  float angle3D           = 0.0 :(deg);
} gcs0Scene0;

%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_NAV :current view mode selected;
} gcs0Scene1;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_NAV :current view mode selected;
} gcs1Scene1;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_NAV :current view mode selected;
} gcs2Scene1;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_NAV :current view mode selected;
} gcs3Scene1;

%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_COCKPIT :current view mode selected;
} gcs0Scene2;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_COCKPIT :current view mode selected;
} gcs1Scene2;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_COCKPIT :current view mode selected;
} gcs2Scene2;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_COCKPIT :current view mode selected;
} gcs3Scene2;

%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_CAMERA :current view mode selected;
} gcs0ScenePIP;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_CAMERA :current view mode selected;
} gcs1ScenePIP;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_CAMERA :current view mode selected;
} gcs2ScenePIP;
%Dir gcsScene_ref {
  char showPanel       = 0 :show panel;
  char viewMode        = VIEW_CAMERA :current view mode selected;
} gcs3ScenePIP;

%Dir scbmpinfoheader_ref {
  ushort bfType          = 0 :type indicator for bitmap files - always set to 'BM';
  ulong  bfSize          = 0 :size of the whole file in bytes;
  ulong  bfReserved      = 0 :reserved bytes - must be 0;
  ulong  bfOffBits       = 0 :byte offset from the BitmapFileHeader to the start of the image;
  ulong  biSize          = 0 :number of bytes required by the #bmpinfoheader_ref structure;
  ulong  biWidth         = 0 :width of bitmap in pixels;
  ulong  biHeight        = 0 :height of bitmap in pixels;
  ushort biPlanes        = 0 :number of planes for the target device (always = 1);
  ushort biBitCount      = 0 :number of bits per pixel,                                               must be 1,           4, 8, or 24;
  ulong  biCompression   = 0 :type of compression for a compressed bitmap,                            In a 24-bit format,  the variable is set to 0;
  ulong  biSizeImage     = 0 :size in bytes of the image;
  ulong  biXPelsPerMeter = 0 :horizontal resolution,                                                  in pixels per meter, of the target device for the bitmap;
  ulong  biYPelsPerMeter = 0 :vertical resolution,                                                    in pixels per meter, of the target device for the bitmap;
  ulong  biClrUsed       = 0 :number of color indexes in the color table actually used by the bitmap (0 for 24 bit);
  ulong  biClrImportant  = 0 :number of color indexes considered important for displaying the bitmap, if value is 0 all colors are important;
} scbmpinfoheader;

%define SCENECAPTURE_OFF  0
%define SCENECAPTURE_REAL 1
%define SCENECAPTURE_ALL  2

%Dir sceneCapture_ref {
  char mode = SCENECAPTURE_OFF :0=off, 1=real, 2=all;
  char window = 0 :scene window to use (-1 = off);
  char singleShot = 0 :grab single image;
  char singleShotMode = SCENECAPTURE_ALL :1=real, 2=all;
  double updateDt = 1 :update rate for capure;
  double lastUpdate = 0.0 :time of last capture;
  char init = 1 :init flag;
  long imageNo = 0 :image number;
  int quality = 95 :jpeg quality setting (if using jpeg);
  string dir      = "images\0                                                      " : ;
  string dataname = "imagecap.txt\0                              " : ;
  string filename = "image%04d.bmp\0                             " : ;
  string fullPath = "01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789" : ;
  dir scbmpinfoheader_ref hdr = scbmpinfoheader :header;
} sceneCapture;

%Dir winInfo_ref {
   int winNo = 4: openGl viewport number ;
   double mvm[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}: model view matrix;
   double mpm[16]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}: model projection matrix;
   int viewport[4]={0,0,0,0}: viewport information;
} winInfo;

%Dir scenes_ref {
  dir sceneGlobal_ref  global  = sceneGlobal  :global scene data;
  dir scene_ref        s0      = scene0       :scene window 0;
  dir scene_ref        s1      = scene1       :scene window 1;
  dir scene_ref        s2      = scene2       :scene window 2;
  dir scene_ref        sPIP    = scenePIP     :scene window PIP;
  dir sceneCapture_ref capture = sceneCapture :capturing images;
  dir scThreats_ref    th      = scThreats    :threat positions;
  dir imViewer_ref     viewer  = imViewer     :info for image viewer;
  dir winInfo_ref      winInfo = winInfo      :window information;
} scenes;

