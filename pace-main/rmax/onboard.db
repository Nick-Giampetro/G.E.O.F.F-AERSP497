%define ACTUATORS_RMAX 0
%define ACTUATORS_PWM 1
%define ACTUATORS_R22 3
%define ACTUATORS_GST 4
%define ACTUATORS_EXT 5
%define ACTUATORS_PSP 6
%define ACTUATORS_MESSAGE 7
%define ACTUATORS_FCP_MIXED_PWM 8

%Dir onboardSet_ref {
  int init = 1     :set to 1 to process new settings;
  uint type = 0 :type vehicle;
  uint uniqueID = 0 :unique identifying number;
  uint actuators = ACTUATORS_RMAX  :0=rmax, 1=pwm, 3=R22, 5=EXT, 6=PSP, 7=message, 8=FCP;
  string datalinkHost    = "ranger\0                      ": host name of machine to connect to;
  string ipcHost         = "pointer\0                     ": host name of machine to connect to;
  string relay_connectTo = "pointer\0                     ": host name of machine to connect to;
  int relay_port=6 : ;
  int relay_baud = 38400 : ;
  int relay_useSerial = 1 : ;
  int relay_useSock   = 0 : ;
  int relay_isServer  = 1 : ;
  int relay_portNum = SI_RELAY1: ;
  string welcomeMessage = "\0                                                                    " : ;
  string configDateTime = "\0                                                                    " : ;
  string ethernetIpAddress = "192.168.54.11         " :for self on fcs20;
  string ethernetMask      = "255.255.255.0         " : ;
  string ethernetGateway   = "192.168.54.1          " : ;
} onboardSet;

%include "serial.dbh"

%Dir serialPort_ref {
  int dataSource = PORT_SITL :0=off,1=on,2=SITL;
  int port=4 : ;
  int si_port = SI_DATALINK1 :SITL port;
  int baud = 38400 : ;
  int portNum   = SI_DATALINK1: ;
} onboardPortDatalink1;

%Dir serialPort_ref {
  int dataSource = PORT_SITL: 0=off,1=on,2=SITL;
  int port=14 : ;
  int si_port = SI_DATALINK2 :SITL port;
  int baud = 9600 : ;
  int useSerial = 0 : ;
  int useSock   = 1 : ;
  string connectTo = "gnat\0                    ": host name of machine to connect to;
  int portNum   = SI_DATALINK2: ;
} onboardPortDatalink2;

%include "datalink.dbh"

%Dir datalinkHeader_ref {
} obDatalinkHeader, obDatalinkMessageHeartbeat;

%Dir datalinkMessage0_ref {
} obDatalinkMessage0;

%Dir datalinkMessage1_ref {
} obDatalinkMessage1;

%Dir datalinkMessageRmtCmd_ref {
} obDatalinkMessageRmtCmd;

%Dir datalinkMessageRmtCnsl_ref {
} obDatalinkMessageRmtCnsl;

%Dir datalinkMessageGetdir_ref {
} obDatalinkMessageGetdir;

%Dir datalinkMessageSenddir_ref {
} obDatalinkMessageSenddir;

%Dir datalinkMessageUp0_ref {
} obDatalinkMessageUp0;

%Dir datalinkMessagePWM_ref {
} obDatalinkMessagePWMToUs, obDatalinkMessagePWMFromUs;

%Dir datalinkMessageAutopilotDels_ref {
} obDatalinkMessageAutopilotDels;

%enum ignoreUpMaskOpt {UPIGNORE_ALL=-1,UPIGNORE_NONE=0,UPIGNORE_P1=1,UPIGNORE_P2=2,UPIGNORE_P1P2=3,UPIGNORE_IPC=4};

%rem this number needs to be odd, change stuff below
%define MAXNUMBEROFSENDDIRS 5

%Dir obDatalinkSet_ref {
  char   sendIPC0             = 0     :send IPC0 out IPC;
  char   sendIPC1             = 0     :send IPC1 out IPC;
  char   sendIPC12            = 0     :send IPC1 out IPC2;
  char   sendM0M1IPC          = 0     :send m0 and m1 over IPC link;

  char   sendExtMan0          = 0     :send IPC0 out IPC;
  char   sendExtMan2          = 0     :send extman2 out IPC;
  char   sendVFIPC            = 0     :send vision formation IPC;
  char   sendRFIPC            = 0     :send rangefinderIPC  (same message as VFIPC);

  char   actuatorCommandsIPC  = 1     :send commands, not estimates, out IPC;
  char   relayP1              = 0     :relay data over datalink1;
  char   relayP2              = 0     :relay data over datalink2;
  char   relayob2stdio        = 0     :relay ob2 stdio ;

  char   minSendSize          = 1     :min bytes to relay at a time;
  char   sendSquitter         = 0     :send squitter message;
  char   relaySquitterToOb2   = 0     :relay the squitter msg to ob2;
  char   sendVFlink1          = 0     :send VF over link1;

  char   sendCam0             = 0     :send Cam0 out IPC;
  char   sendRoverLink        = 0     :send roverLink messages;
  char   sendVFlink2          = 0     :send VF over link2;
  char   sendCam0ToPF         = 0     :send camera data to PF;

  char   sendVFMult           = 5     :multiples of VF to send;
  char   sendSlungDownCmd     = 0     :send commands to slungload;
  char   sendSlungUp          = 0     :send data from slungload;
  char   sendSlungStatus      = 0     :send slung status to gcs;

  char   resetIfDown          = 0     :reset link if detect it is down;
  char   sendLaserScan        = 0     :send laser scans over link2, 1 = hoku, 2 = sick;
  char   sendLaserScanIPC     = 0     :send laser scans over link3, 1 = hoku, 2 = sick;
  char   sendPointCloud       = 0     :send point cloud over ipc;

  char   sendQuadStatus       = 0     :send quadrotor status to gcs;
  char   sendQuadIPCmd        = 0     :send quadrotor ip commands to onboard 2;
  char   send2dCov            = 0     :send 2d covariance to ground;
  char   relayFlightPlanToOb2 = 0     :relay flight plans to ob2 when received;

  char   sendM1B              = 0     :send message1b;
  char   numberOfCameras      = 0     :cameras to use to populate pan/tilt/fov data (1-4);
  char   ignoreFlightPlansFromIPC = 0  :ignore flight plans from IPC (treat as proposed flight plans), 2=don't even forward it;
  char   ignoreUpMask        = UPIGNORE_NONE     :(ignoreUpMaskOpt), do not use up messages from masked links;
  
  char   battTempFuelSource  = 0     :0=fcs20/ycs, 1=svi2ap, 2=A2D;
  char   relayDataRecordP1   = 1     :relay data over datalink1;
  char   relayDataRecordP2   = 1     :relay data over datalink2;
  char   datUploadAckP1      = 1     :relay dat upload over datalink1;
  
  char   datUploadAckP2      = 1     :relay dat upload over datalink2;
  char   sendPayloadStatus   = 0     :Send the payload status message to the OCS;
  char   relayPointPosToOb2  = 0     :relay green circle to ob2;
  char   relayDatalinkStyle  = 0     :assume relay port is in datalink format;

  char   otherStatusSource   = 0     :0=svi,1=vf,2=ardupilot;
  char   gpsrefLink1         = 1     :send differential correction over link 1;
  char   gpsrefLink2         = 1     :send differential correction over link 2;
  char   revertNvtlMsg       = 0     :1=revert to old fixed size rtca messages;

  char   sendM2              = 3     :1=link1,2=link2,3=both (only if transponder on);
  char   sendGpsToGround     = 0     :send raw gps to ground;
  char   sendRawDataLog      = 0     :send Raw data log to gcs (0=no,1=link1,2=link2,3=both);
  char   RawDataSimOn        = 0     :boolean for sim time gps shift(0-real,1=sim);

  char   visionStatusSource  = 0     :0=ip,1=vf,2=slip,3=platform,4=slam;
  char   sendDJIGuidance     = 0     :0=off,1=on;
  char   sendHealth          = 0     :0=off,1=on;
  char   sendGpsDetails      = 0     :0=off,1=on;
  
  char   sendAutopilotDels   = 1     :0=off,1=when in manual,2=always;
  char sendSquitterMini      = 0 : ; char relayEPMstatus        = 1 : ;

  char sendEchoSonar         = 0 : ;
  char sendBattery           = 0 : send cell voltage to ground;
  char sendNavTime           = 0 : send the navTime message;
  char sendExtMan3           = 0 : send extMan3 message;

  char currentSource         = 0 :0=yrd,1=quadsas;
  char relayPredTrajToGcs          = 0   : ;
  char relayDeckPredictInfoToGcs   = 0   : ;
  char relayMPPITrajsToGcs         = 0   : ;

  char sendMySquitterIPC           = 0   : ;
  char rmtCnsl                     = 2   : 0-off, 1- never limit the rate, 2-limited downlink to a specified rate, 3-rate won't be limited if messages are different   ;
  char sendBoomData                = 0   :send Boom touch sensor ;
  char sendPSUPilotSimOut          = 0   :send PSU Pilot Sim Message;

  int tempLow  =     0 :temperature < for low (centa-deg);
  int tempHigh = 50000 :temperature > for high (centa-deg);

  int tempOver = 50000 :temperature > for high (centa-deg);
  int align7 = 0 : ;

  int generatorExternalPower  = 20000 :voltage > for external power indication (mV);
  int generatorDrop           = 200   :voltage drop for generator switching (mV);

  double rpmLow  = 800 :(rpm);
  double rpmHigh = 890 :(rpm);
  double rpmMaxDiff = 50  :(rpm) primarily used when another system tracks RPM and reports result - to determine whether properly tracking;

  char   useCmdCam0           = 0     :use commaned camera positions (instead of measured) in cam0;
  char   forwardgpsRef        = 0     :forward gpsRef messages over relay;
  char   enableFcs20          = 0     :enable fcs20 downlink message;
  char   sendYJData           = 0     :send Yellow Jacket extra sensor data;
  int    getDirNum[5]         = {-1,-1,-1,-1,-1}     :getDir dirNum;

  double updateDtIPC0         = 0.02  :update rate;
  double updateDtIPC1         = 0.02  :update rate;
  double updateDtRawDataLog   = 0.01  :update rate;
  double updateDtExtMan0      = 0.02  :update rate extMan0;
  double updateDtExtMan2      = 0.02  :update rate extMan2;
  double updateDtCam0         = 0.02  :update rate cam0;
  double updateDtRoverLink    = 5.0   :update rate roverlink;
  double updateDtVFIPC        = 0.02  :update rate VF IPC;
  double updateDtSquitter     = 0.2   :update rate of squitter;
  double updateDtSquitterMini     = 0.2   :update rate of squitter mini;
  double updateDt0_1          = 0.01   :update rate m0 link 1;
  double updateDt0_2          = 0.01   :update rate m0 link 2;
  double updateDt0_3          = 0.1   :update rate m0 ipc link;
  double updateDt1            = 1.0   :update rate m1;
  double updateDt2            = 1.0   :update rate m2;
  double updateDtYJData       = 0.0   :update rate yellow jacket data;
  double updateSendDirDt[5] = {0,0,0,0,0}   :update rate sendDir (0=off);
  double uplinkTimeOut        = 5.0   :(sec) declare uplink bad if this long since message;
  double updateDtSlungDownCmd = 0.2   :update rate slunglink;
  double updateDtSlungUp      = 0.1   :update rate slunglink;
  double updateDtSlungStatus  = 0.2   :update rate slunglink;
  double updateDtLaserScanInfo= 1.0   :update rate raw laser scan;
  double updateDtLaserScan    = 1.0   :update rate raw laser scan;
  double updateDtLaserScanInfoIPC= 1.0   :update rate raw laser scan;
  double updateDtLaserScanIPC    = .2   :update rate raw laser scan;
  double updateDtPointCloud   = .05   :update rate of point cloud sent via ipc;
  double downloadConfigFileDt = 0.55  :download rate for config cmd file;
  double gpsDeniedMinToggleTime=1.0   :min time to turn gps denied off after turning it on;
  double updateDtQuadStatus   = 0.1   :update rate quadlink;
  double updateDtQuadIPCmd    = 0.1   :update rate quad ip cmd;
  double updateDt2dCov        = 0.1   :update rate quad ip cmd;
  double updateDtDjiGuidance  = 0.1   :update rate of dji guidance;
  double updateDtGpsToGround  = 0.2   :update rate gps to ground;
  double fuelFilterTc         = 10.0  :analog fuel level warning time constant;
  double updatePayloadStatusDt = 10.0 :Send on change, or every 10 seconds;
  double updateDtDownloadingPlan = 0.5 :(sec);
  double updateDtHealth       = 1.0   :update rate (sec);
  double updateDtGpsDetails   = 1.0   :update rate (sec);
  double updateDtAutopilotDels = 1.0  :update rate (sec);
  double updateDtBattery      = 2.0   :update rate (sec);
  double updateDtNavTime      = 0.01  :update rate navTime;
  double updateDtExtMan3      = 0.04  :update rate for external formation;
  double minDtRmtCnsl         = 1.0   : won't allow remote console below this dt;
  double updateDtBoom          = 0.5   :update rate (sec) ;
  double updateDtPSUPilotSimOut = 0.01 :update rate (sec) ;
} obDatalinkSet;

%Dir obDatalinkWork_ref {
  double rxTimeLink1     = -99.0  :time of last update from link 1;
  double rxTimeLink2     = -99.0  :time of last update from link 2;
  double rxTimeIPC       = -99.0  :time of last update from IPC;
  double rxTimeIPC2      = -99.0  :time of last update from IPC2;
  double rxTimeRelay     = -99.0  :time of last update from relay;
  double rxTimeRoverLink = -99.0  :time of last update from rover;
  double lastUpdate0_1 = 0.0      :time of last update (send);
  double lastUpdate0_2 = 0.0      :time of last update (send);
  double lastUpdate0_3 = 0.0      :time of last update (send);
  double lastUpdate1 = 0.0        :time of last update (send);
  double lastUpdate1B = 0.5       :time of last update (send);
  double lastUpdate2 = 0.25       :time of last update (send);
  double lastUpdateSendDir[5] = {0,0,0,0,0}  :time of last update (send);
  double lastUpdateIPC0   = 0.0   :time of last update (send);
  double lastUpdateIPC1   = 0.0   :time of last update (send);
  double lastUpdateRawDataLog = 0.0 :time of last update (send);
  double lastUpdateExtMan0 = 0.0   :time of last update (send);
  double lastUpdateExtMan2 = 0.0   :time of last update (send);
  double lastUpdateCam0   = 0.0   :time of last update (send);
  double lastUpdateHURT0  = 0.0   :time of last update (send);
  double lastUpdateSquitter = 0.0 :time of last squitter send;
  double lastUpdateSquitterMini = 0.0 :time of last squitter mini send;
  double lastUpdateVFIPC   = 0.0   :time of last update (send);
  double lastUpdateRoverLink = 0.0 :time of last update (send);
  double lastUpdateSlungDownCmd = 0.0 :time of last update (send);
  double lastUpdateSlungUp = 0.0   :time of last update (send);
  double lastUpdateSlungStatus = 0.0   :time of last update (send);
  double lastUpdateLaserScanInfo = 0.0   :time of last update (send);
  double lastUpdateLaserScan = 0.0   :time of last update (send);
  double lastUpdateLaserScanInfoIPC = 0.0   :time of last update (send);
  double lastUpdateLaserScanIPC = 0.0   :time of last update (send);
  double lastUpdatePointCloud = 0.0 : time of last point cloud was sent (send);
  double lastConfigFileDownload = 0.0 :time of last download (send);
  double lastUpdateYJData  = 0.0   : time of last update (send);
  double lastGPSDenied = 0.0       :time of last gps denied selection;
  double lastUpdateQuadStatus = 0.0 :time of last update (send);
  double lastUpdateQuadIPCmd    = 0.0   :time of last update (send);
  double lastUpdate2dCov        = 0.0   :time of last update (send);
  double lastUpdateDjiGuidance  = 0.0   :time of last update (send);
  double lastUpdatePayloadStatus = 0.0  :time of last update (send);
  double lastUpdateGpsToGround   = 0.0   :time of last update (send);
  double lastUpdateDownloadingPlan = 0.0 :time of last update (send);
  double fuelFilterState = 0.5 : ;
  double lastUpdateHealth        = 0.0 :time of last update (send);
  double lastUpdateGpsDetails    = 0.0 :time of last update (send);
  double lastUpdateAutopilotDels = 0.0 :time of last update (send);
  double lastUpdateBattery       = 0.0 :time of last update (send);
  double lastUpdateNavTime       = 0.0 :time of last update (send);
  double lastUpdateExtMan3       = 0.0 :time of last update (send);
  double lastUpdateRmtCnsl       = 0.0 :time of last update (send);
  double lastUpdateBoom          = 0.0 :time of last update (send);
  double lastUpdatePSUPilotSimOut = 0.0 :time of last update (send);

  int    lastPointCloudSickItime = 0   :last point cloud;
  int    lastPointCloudHokuyoItime = 0   :last point cloud;

  uint  itime       = 0     :number of messages received;
  uchar lastVisionCmd  = 255   :uniqueID of last Vision command message;
  uchar lastVisionStartCmd  = 255   :uniqueID of last Vision command message;
  uchar newRtcm     = 0     :new RTCM correction data received;
  char  align       = 0   :align;

  ushort lastGpsRef  = GPSREF_ROLL+1 :uniqueID of last GPS reference message;
  ushort lastGpsCmd  = 999   :uniqueID of last GPS command message;
  ushort lastRmtCmd  = 999   :uniqueID of last remote command message;
  ushort lastRmtCmd2 = 999   :uniqueID of last remote command2 message;
  ushort lastNvtlMsg = GPSREF_ROLL+1 :uniqueID of last Novatel message;
  ushort lastUp1ID   = 999   :uniqueID of last up1;
  uchar  lastCamSend = 0     :which camera last sent out m1;
  uchar  whichGpsDetails = 0 :0 means send primary, 1 means send secondary;
  ushort logOverrun = 0      : how many times log message occured since the previous downlink;

  ushort lastRmtCmd3 = 999   :uniqueID of last remote command2 message;
  ushort getdirID    = 999   :number of last getdir;
  ushort senddirID   = 999   :number of last senddir;
  ushort relayID     = 999   :number of last relay;

  int drRelayPktRecvd   = 0     : dr Relay packet received;
  int visionNavPktRecvd = 0     : vision Nav  packet received;

  int vfSent = 0     : ;
  int badHeaderChecksums = 0 : ;

  int badChecksums = 0 : ;
  char newConfigFileData = 0 :flag indicating new config file data rcvd;
  char downloadConfigFile = 0 : ;
  char downloadConfigFileState = 0 : ;
  char loadConfigFileFail = 0 : ;

  long lastViconState = -1 : ;

  char downloadingPlan = 0 : ;
  char downloadingLostComm = 0 : ;
  char align3[2] = {0,0} : ;
  int startIndexToSend = 0 : ;
} obDatalinkWork;

%Dir obDatalink_ref {
  dir serialPort_ref p1           = onboardPortDatalink1    :serial;
  dir serialPort_ref p2           = onboardPortDatalink2    :ethernet;

  dir obDatalinkSet_ref  set  = obDatalinkSet  :settings;
  dir obDatalinkWork_ref work = obDatalinkWork :working area;

  dir datalinkHeader_ref                     header              = obDatalinkHeader                     :raw message header;
  dir datalinkMessage0_ref                   m0                  = obDatalinkMessage0                   :raw message sent;
  dir datalinkMessage1_ref                   m1                  = obDatalinkMessage1                   :raw message sent;
  dir datalinkMessageUp0_ref                 up0                 = obDatalinkMessageUp0                 :raw message received;
  dir datalinkMessageRmtCmd_ref              rmtCmd              = obDatalinkMessageRmtCmd              :raw message received;
  dir datalinkMessageRmtCnsl_ref             rmtCnsl             = obDatalinkMessageRmtCnsl             :raw message sent;
  dir datalinkMessageGetdir_ref              getdir              = obDatalinkMessageGetdir              :raw message received;
  dir datalinkMessageSenddir_ref             senddir             = obDatalinkMessageSenddir             :raw message sent;
  dir datalinkMessageAutopilotDels_ref       autopilotDels       = obDatalinkMessageAutopilotDels       :raw message sent;
 } obDatalink;

%include "rmax.dbh"

%Dir pwmServoMapping_ref {
} pwmServoMapping;

%Dir pwmMultirotor_ref {
} pwmMultirotor;

%define ACT_OK 0
%define ACT_FAIL 1
%define ACT_LOSSEFF 2
%define ACT_CENTEREDLOSSEFF 3
%define ACT_BADSENSOR 4
%define ACT_SYSID 5
%define ACT_DOUBLET 6

%define ACTUATOR_MAX_LATENCY 26

%Dir actuatorIntModel_ref {
  char failFlag = ACT_OK :failure mode (0=no, 1=fail, 2=generic loss of eff input*scale+bias, 3=centered loss of eff scale*(input-bias)+bias, 4=just bad sensor);
  char previousFailFlag =  ACT_OK : failFlag of the previous call ;
  generic char align[6] = {0,0,0,0,0,0} :for alignment;
  double scale = 1 :remap scale factor (0 = frozen, 1= normal);
  double bias  = 0 :remap bias;
  double badSensorOut = 0 :output when sensor is bad;
  double min = -1 :minimum value;
  double max = 1  :maximum value;
  double state = 0 :model position;
  double positionOutput = 0 :position sensor output;
  double sigma = 0.0 :noise on actuator pos measurement;
  double latency = 0.0 : enforce latency in ms;
  double antiBacklash = 0.0 :anti-backlash value;
  double antiBacklashRate = 5.0 :(Hz) anti-backlash onset rate;
  double dither = 0.0 :dither actual input (anti-backlash);
  double lastInput = 0.0 :previous input applied;
  double estimatedInputRate = 0.0 : ;
  double antiBacklashApplied = 0.0 :anti-backlash value;
  double latency_buffer[26] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} : ;
} actuatorIntModel_delm0;

%Dir actuatorIntModel_ref {
  double min = -1 :minimum value;
  double max = 1  :maximum value;
} actuatorIntModel_delm1;

%Dir actuatorIntModel_ref {
  double min = -1 :minimum value;
  double max = 1  :maximum value;
  double bias = -.1 :typical hover value;
} actuatorIntModel_delm2;

%Dir actuatorIntModel_ref {
  double min = -2.5 :minimum value;
  double max = 1  :maximum value;
  double bias = -0.25 :typical hover value;
} actuatorIntModel_delf0;

%Dir actuatorIntWork_ref {
  double delm[3]   = {0,0,0} :moment actuators (our command);
  double delf[1]   = {0}     :force actuators (-1 to 1);
  double delt[1]   = {0}     :throttle actuators (-1 to 1);
  double deldf[2]  = {0,0}   :direct force control (-1 to 1);
  double c_delm[3] = {0,0,0} :*** moment actuators (autopilot command);
  double c_delf[1] = {0}     :*** force actuators (-1 to 1);
  double c_delt[1] = {0}     :*** throttle actuators (-1 to 1);
  double c_deldf[2] = {0,0}  :*** direct force control (-1 to 1);
  double h_delm[3] = {0,0,0} :moment actuators (best estimate for hedge, if auto);
  double h_delf[1] = {0}     :force actuators (-1 to 1);
  double h_delt[1] = {0}     :throttle actuators (-1 to 1);
  double h_deldf[2] = {0,0}  :direct force control (-1 to 1);
  double e_delm[3] = {0,0,0} :moment actuators (other external command);
  double e_delf[1] = {0}     :force actuators (-1 to 1);
  double e_delt[1] = {0}     :throttle actuators (-1 to 1);
  double delw[1]   = {0}     :wheel actuators (-1 to 1);
  double c_delw[1] = {0}     :wheel actuators (-1 to 1);
  double h_delw[1] = {0}     :wheel actuators (-1 to 1);
  double delc[1]   = {0}     :flap actuators (-1 to 1);
  double c_delc[1] = {0}     :flap actuators (-1 to 1);
  double h_delc[1] = {0}     :flap actuators (-1 to 1);
} actuatorIntWork;

%Dir actuatorInt_ref {
  dir actuatorIntWork_ref    work     = actuatorIntWork      :*** working area;
  dir pwmServoMapping_ref    pwmMap   = pwmServoMapping      :pwm servo map data;
  dir pwmMultirotor_ref      pwmMulti = pwmMultirotor        :alternate pwm servo mapping data for multirotors;
  dir datalinkMessagePWM_ref pwmFromUs = obDatalinkMessagePWMFromUs :servo pwm commands;
  dir actuatorIntModel_ref   delm0  = actuatorIntModel_delm0  :virtual acuator model;
  dir actuatorIntModel_ref   delm1  = actuatorIntModel_delm1  :virtual acuator model;
  dir actuatorIntModel_ref   delm2  = actuatorIntModel_delm2  :virtual acuator model;
  dir actuatorIntModel_ref   delf0  = actuatorIntModel_delf0  :virtual acuator model;
} actuatorInt;

%Dir onboard_ref {
  int run  = 1 :flag to onboard code (ignored onboard);
  int init = 1 :initialization flag;
  dir onboardSet_ref     set         = onboardSet        :settings to be changed on the fly;
  dir sensors_ref        sensors     = sensors           :sensors;
  dir navigation_ref     navigation  = navigation        :navigation system;
  dir onboardControl_ref control     = onboardControl    :flight controller;
  dir actuatorInt_ref    actuators   = actuatorInt       :actuator interface;
  dir obDatalink_ref     datalink    = obDatalink        :datalink to gcs;
} onboard;

