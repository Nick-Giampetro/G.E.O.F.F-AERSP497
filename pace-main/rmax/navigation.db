%Dir navinit_ref {
  int    type = 0 :0 = normal, 1 = airborne, 2 = heading;
  int    steps = 500 : ;
  double datumLat =  33.659653 :datum latitude (deg-N);
  double datumLon = -84.66333  :datum longitude (deg-E);
  double datumAlt = 745.00     :datum altitude (ft);
  double phi   = 0.0 :initial Euler angles (deg);
  double theta = 0.0 :initial Euler angles (deg);
  double psi   = 0.0 :initial Euler angles (deg);
  double x0[3] = {0,0,-25.0/12}   :initial position in L (ft);
  double v0[3] = {0,0,0}   :initial velocity in L (ft/s);
  double ab0[3] = {5.5,-6.0,0} :intial biases in B (ft/s2), z-axis is replaced on init;
  double wb0[3] = {0,0,0} :intial biases in B (rad/s), air mode only;
  double th0 = 0 :initial terrain height (ft);
  double psi_bias0 = 0 :initial magnetometer angle bias;
  double tbias0 = 0 : initial time bias (m);
  double absPress = 0 :initial absolut pressure (psi);
  Double wind[3] = {0,0,0} :(ft/s) initial wind estimate;
  double P0UnknownRollPitch  = 1.0         :air mode only;
  double P0UnknownHeading    = 100.0       : ;
  double P0UnknownPositionH  = 100000000.0 :position horizontal;
  double P0UnknownPositionV  = 100000000.0 :velocity vertical;
  double P0UnknownVelH       = 100000.0    :vel horizontal;
  double P0UnknownVelV       = 10000.0     :vel vertical;
  double P0velH              = 0.0         :vel horizontal;
  double P0velV              = 0.0         :vel vertical;
  double P0ab                = 1.0         :x/y accel bias;
  double P0wb                = 0.0001      :gyro bias, air mode only;
  double P0Th                = 1.0         :terrain height initial covariance;
  schar GPSInits    = 3 : ;
  schar magnetInits = 5 : ;
  schar airInits    = 3 : ;
  schar satInits    = 5 : ;
  Char align[12] = {0,0,0,0,0,0,0,0,0,0,0,0} : ;

} navinit;

%define NAV_COV_UDU 0
%define NAV_COV_P 1

%if defined(VL_ARCH_C6713)
%define NAVSTATES_NFEATURES 0
%else
%define NAVSTATES_NFEATURES 64
%define HAVE_FEATURES 1
%endif

%define NAVSTATES_BASE 16
%define NAVSTATES (NAVSTATES_BASE + NAVSTATES_NFEATURES*3)
%define NAV_R0 0
%define NAV_R1 1
%define NAV_R2 2
%define NAV_PX 3
%define NAV_PY 4
%define NAV_PZ 5
%define NAV_VX 6
%define NAV_VY 7
%define NAV_VZ 8
%define NAV_AX 9
%define NAV_AY 10
%define NAV_AZ 11
%define NAV_WX 12
%define NAV_WY 13
%define NAV_WZ 14
%define NAV_TH 15
%define NAV_Q0 (NAVSTATES_BASE + NAVSTATES_NFEATURES*3 + 0)
%define NAV_Q1 (NAVSTATES_BASE + NAVSTATES_NFEATURES*3 + 1)
%define NAV_Q2 (NAVSTATES_BASE + NAVSTATES_NFEATURES*3 + 2)
%define NAV_Q3 (NAVSTATES_BASE + NAVSTATES_NFEATURES*3 + 3)

%Dir navconfigure_ref {
  char enableGPS    = 1 :enable flag for sensor integration (2 altimeter only);
  char enableAGL    = 1 :enable flag for sensor integration;
  char enableMagnet = 1 :enable flag for sensor integration (2 ignores residual) (3 ignores residual if motor on);
  char notUsed      = 0 :(no longer used, left here to keep alignment until replaced);
  char enableAirVel = 0 :enable flag for sensor integration;
  char enableAir    = 0 :enable flag for sensor integration (2 use gps for altitude if available);
  char enableIP     = 0 :enable flag for sensor integration;
  char enableGPShdg = 0 :enable flag for sensor integration (2 ignores residual);

  char enableFake   = 0 :enable flag for sensor integration;
  char enableHub    = 1 :enable flag for checking hub;
  char enableSLAM   = 0 :enable flag for sensor integration (multiple slam methods available, uses whatever is on);
  char enableVisualSLAM   = 0 :enable flag for sensor integration: 0=off,1=all,2=features only,3=no update;
  char enableVicon  = 0 :enable flag for sensor integration;
  char enableTC     = 0 :enable tightly coupled nav filter ;
  char enableOF     = 0 :enable flag for optical flow;
  char enableZeroVelOnGround = 0 :enable flag to assume not moving with wow=1;

  char enableImpf   = 0 :enable flag for image matching;
  char enableHdgBiasEstimation = 0 :enable flag to estimate magnet bias;
  char whichVisionFunction = 1 : 0=uncorr, 1=fully correlated, 2 = external feature covariance;
  char autoEnableGps       = 0 : 0=off, 1=gpsOn, 2=gpsOn, visualSLAM off;
  char fakeGPS    = 0 :20 for 5Hz fake, 0=off;
  char fakeMagnet = 0 :20 for 5Hz fake, 0=off;
  char sonUpdateMode = 0 :always use sonar, even if out of range (relying on it);
  char ofSource   = 0 :0 = centeye optical flow sensor, 1 = ob2 opticalflow.cpp;

  uchar skips = 1 :(frames) update rate of P;
  char enableGPSVel = 1 :1=use velocity data from GPS, 2=only use horizontal velocity data from GPS (requires enableGPS>0);
  Char align[6] = {0,0,0,0,0,0} : ;
  
  int nNavStates = NAVSTATES_BASE    : number of Kalman filter states (requires reinit);
  int covarianceRepresentation = NAV_COV_UDU    : 0=UDUt, 1=P (requires reinit);

  Double RgpsPos[3][3] = {{25*25,25*25,30*30},{10*10,10*10,15*15},{5*5,5*5,7*7}} :GPS meas noise;
  Double RgpsVel[3][3] = {{10*10,10*10,15*15},{7*7,7*7,10*10},{5*5,5*5,7*7}} :{25*25,25*25,30*30}GPS meas noise;
  double RgpsHdg[1] = {100} :gps heading meas noise;
  double Rmag[1] = {100} :magnetometer meas noise;
  Double Rip[3] = {0.1,10,10}    :image proc variable (pixels^2);
  double RfakeVelGround = 1   :fake measurement;
  double RfakeVelAir = 10000  :fake measurement;
  double RfakeAccAir = 1000   :fake measurement;
  Double imuR[3] = {2.0/12,0,(25.0-15.5)/12} :position of IMU (ft);
  Double gpsR[3] = {-29.0/12,3.5/12,(25.0-31)/12} : {-1.5,-0.5,-2} position of GPS (ft);
  Double airR[3] = {2.0/12,0,(25.0-15.5)/12} :position of air data sensor (ft);
  double airHalfQuant = .25 :(ft) half of the quantization of baro alt;
  double dutc    = 0 :(sec) descrete update time constant;
  Double dutcPos[3] = {0,0,0} :(sec) time constant for position update, NED;
  Double dutcVel[3] = {0,0,0} :(sec) time constant for velocity update, NED;
  double Q_magb = .00001  : magnet bias process noise;
  double R_magb = .1       : magnet bias measurement noise;
  double posOutlier = 1000 :(ft) gps outlier detection, 0=disable;
  double velOutlier = 0    :(ft/s) gps outlier detection, 0=disable;
  double altOutlier = 0    :(ft) baro outlier detection, 0=disable;
  double zTestGPS = 0      :z-test for GPS (2.37 for 50%);
  double zTestGPSvel = 0   :z-test for GPS vel;
  Double gpsResLimit[3]   = {0,0,0}  :(ft) limit GPS position residual, NED;
  Double gpsVelResLimit[3] = {0,0,0} :(ft/s) limit GPS vel residual, NED;
  Double dxdtLim[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0} :state rate limits (dutc);
  double R_slam    = 1.0  :(ft2);
  double R_slamVel = 1.0  :(fps2);
  double R_slamPsi = 0.01 :(rad2);
} navconfigure;

%define WOW_AGL 0
%define WOW_MANUAL 1
%define WOW_INFER 2
%define WOW_MECH 3
%define WOW_SONAR 5
%define WOW_SONSAFE 6
%define WOW_MESSAGE 7
%define WOW_FWLAUNCH 8
%define WOW_NONE 99

%define ALTIMETERSET_MANUAL 0
%define ALTIMETERSET_GPS 1
%define ALTIMETERSET_DATUM 2

%include "wmm.dbh"
%Dir navset_ref {
  double Rair = 150*150     :air data variance (ft2);
  double RradMult= 0.5    :radar s.d. per alt;
  double RradMin = 1*3    :radar s.d. min (ft);
  double Q[16] = {0.0004,0.0004,0.0004,0,0,0,0.01,0.01,0.01,0.001,0.001,0.001,0.00001,0.00001,0.00001,0.00001} :diagonal process noise;
  double QperV = 0.2*0.2 :terrain h dot cov per estimate velocity squared;
  double Qmin  = 0.1*0.1 :minimum terrain h dot cov;
  double Qfp   = .01       : feature point process noise;
  double autoEnableGpsMaxRes = 4 :(ft/s) maximum velocity residual with Gps off;
  double hground = 25.0/12 + 0.375 :(ft) altitude below-which we are declared on the ground (wow AGL);
  double zgear   = 25.0/12         :(ft) altitude when sitting on ground;
  double wowImuFiltDt   = 0.1  :(sec) update time const of wow imu accel filter;
  double wowK           = 0.93 :discrete gain on wow filter (0-1)(WOW_AGL);
  double wowKraw        = 0.80 :discrete gain on wow filter using raw sonar(0-1)(WOW_AGL);
  double wowConfidenceOn  = 0.5 :confidence in wow to go ground mode (if P(ground)>this);
  double wowConfidenceOff = 0.5 :confidence in wow to go to air mode (if P(ground)<this);
  double rotorSpinTime  = 15   :(sec) rotor spin time (WOW_INFER);
  double wowAltTol      = 10   :(ft) in certain wowMethods, set altitudeAGL to zero when within this tolerance of zero when wow is true;
  double altitudeOverride = 5  :(ft) in some modes, go to air mode if this high as a backup transition method;
  double minThrottleWow = 0.6  :(WOW_INFER);
  double inferFiltTc    = 5.0  :(sec)(WOW_INFER);
  double collectiveDrop = 0.1  :(WOW_INFER);
  double inferTestAGL   = 20.0 :(ft) do not use infer wow on above this AGL;
  double magBias = 0 :(rad) magnetometer bias;
  double grav0 = 32.08822 :gravity at equator (ft/s2);
  double grav1 = 0.00529  :gravity model parameter (nd);
  double imuDt = 0.01 :update rate of IMU (s);
  double imuTc = 0.1  :update time cons of ang accel filter (s);
  double accFiltDt    = 0.25 :(sec) update time const of accel filter;
  double g10 = WMM_G10 :World Magnetic Model;
  double g11 = WMM_G11 :World Magnetic Model;
  double h11 = WMM_H11 :World Magnetic Model;
  double altimeterSetting = 29.92 :(in-Hg) altimeterSetMode=0 to use;
  double assumedCAS = 40.0 :(ft/s);
  double freqAccelBiasAir = 0      :(Hz) accel bias frequency while in air;
  double freqAccelBiasGnd = 0.0001 :(Hz) accel bias frequency while on ground;
  double tbias0 = 0.0 : initial time bias (m);
  double rpmFreezeBottom = -1 :(rpm) bottom of RPM range with bad accel data;
  double rpmFreezeTop    = -1 :(rpm) top of RPM range with bad accel data, only use of vehicle not moving during spin up;
  double vibeTime = 0 :(sec) imu window averaging (0=off), if used then this adds time delay to system;
  double altimeterSetAdjustStep = 0.001 :do make a whole lot bigger than this;
  double wowLandManualThrottleBackupLevel = -0.9 :in manual, switch to land if throttle/thrust is below this;
  double wowTakeoffManualThrottleBackupLevel = 0.9 :in manual, switch to air if throttle/thrust is above this;
  double rotorRpmMatchMinCountdown = 1.0 :The minimum time in seconds that the countdown can reach if the RPM isn't matched;
  double n_lf_TC = 0.5 : load factor LP time constant;
  uchar wowMethodTakeoff = WOW_SONAR :0=agl,1=manual,2=infer,3=mechanical switch,5=raw sonar,99=none;
  uchar wowMethodLand    = WOW_SONAR :0=agl,1=manual,2=infer(do NOT use in flight),3=mechanical switch,5=raw sonar,6=sonar safety,99=none;
  uchar wowLandInferBackup = 0 :If using wow landing with sonar or sonar safety, this allows the inferred landing method to also be active;
  uchar wowTakeoffInferBackup = 0 :If using wow takeoff with sonar, this allows the inferred takeoff method to also be active;
  uchar wowLandManualThrottleBackup = 0 :does wow switch in manual control based on throttle (in addition to other methods),1=delt,2=delf;
  uchar wowTakeoffManualThrottleBackup = 0 :does wow switch in manual control based on throttle (in addition to other methods),1=delt,2=delf;
  uchar rotorRpmMatchRequiredTakeoff = 0 :Whether the rotor RPM is required to match the target (within tolerance) for takeoff;
  uchar autoDatum = 0 :automatically do datum with this many sats;
  uchar autoDatumPackets = 8 :(packets);
  uchar doIMUBIT = 1 :IMU Built In Test;
  uchar doAirBIT = 1 :Air data (static pressure) Built In Test;
  uchar altimeterSetMode = ALTIMETERSET_DATUM :0=manual, 1=gps, 2=datum;
  uchar revertFlag = 0 :used to revert code;
  uchar useModelAccel[3] = {0,0,0} :use model instead of hardware accel (0=off,1=ground,2=air,3=both);
  uchar forceWowIMUfilt = 0 :do wow IMU filter;
  uchar altimeterSetAdjust = 0 :adjust altimeter setting slowly with GPS;
  uchar gpsOutlierMethod = 1 : ;
  Char align[5] = {0,0,0,0,0} : ;
} navset;

%define NAVMEAS 3

%define POS_LATENCY 100
%define VEL_LATENCY 100
%define IP_LATENCY 100

%define NAV_INITIALIZING 0
%define NAV_RUNNING 1
%define NAV_BIT 2
%define NAV_RUNNING_NOGPS 3
%define NAV_RUNNING_NOXYGPS 4
%define NAV_RUNNING_NOXYGPS_VIS 5
%define NAV_RUNNING_VISION 7
%Dir navout_ref {
  int init = 0 :init step;
  ulong itime = 0 :nav update;
  double time = 0.0 :time estimate;
  double gpsRxTime = 0.0 :(sec) time of last received position packet;
  char wow = 1 :weight on wheels;
  double p_b_e_L[3] = {0,0,0} :position of body wrt Earth expressed in local frame;
  double v_b_e_L[3] = {0,0,0} :velocity of body wrt Earth expressed in local frame;
  double a_b_e_L[3] = {0,0,0} :accel of body wrt Earth expressed in local frame;
  double w_b_e_L[3] = {0,0,0} :angular rate of body wrt Earth expressed in LG;
  double fil_a_b_e_L[3] = {0,0,0} :accel of body wrt Earth expressed in local frame, filtered;
  double v_b_e_B[3] = {0,0,0} :velocity of body wrt Earth expressed in body;
  double a_b_e_B[3] = {0,0,0} :accel of body wrt Earth expressed in body frame;
  double w_b_e_B[3] = {0,0,0} :angular rate of body wrt Earth expressed in body (average of 2 frames);
  double fil_a_b_e_B[3] = {0,0,0} :accel of body wrt Earth expressed in body frame, filtered;
  double q[4] = {1,0,0,0} :attitude quaternion;
  double fil_s_b_e_L[3] = {0,0,0} :specific accel of body wrt Earth expressed in body frame, filtered;
  double fil_n_b_e_B[3] = {0,0,1} : load factor in body frame fil_s_b_e_B/g;
  double fil_n_b_e_V[3] =  {0,0,1} : load factor in velocity frame;
  double fil_n_lf_abs = 1 : absolute load factor, magnitude of applied accel vector / g (filtered LP);
  double gs = 0 : ground speed estimate, sqrt( SQ(v_b_e_L[0]) + SQ(v_b_e_L[1]));
  double altitudeAGL = 0.0 :altitude above terrain;
  double rpm = 900 :(rpm) of rotor;
  char rpmGood = 0 :true if data is good enough for control;
  char rpmStatus = 0 : (0=off,1=hold,2=open,3=okay,4=low,5=high);
  char inControl = 0 :0=me,1=somebody else;
  char inControlGood = 0 :true if data is good enough for control;
  double gamma = 0 : (rad) flight path angle, xy inertial plane to velocity vector, pitch at airspeeds below Vinf_min_attitude;
  double track = 0 : (rad) track angle, angle to velocity vector projected in xy inertial plane, yaw at airspeeds below Vinf_min_attitude;
  double theta_load[2] = {0,0} :(rad) load angles;
  double theta_dot_load[2] = {0,0} :(ft/s) load angles derivatives;
  double p_l_e_L[3] = {0,0,0} : Load position;
  double v_l_e_L[3] = {0,0,0} : Load velocity wrt Earth expressed in local frame;
  double q_l[4] = {1,0,0,0} :Load atitude;
  double psi_l = 0 : load yaw;
  double psidot_l = 0 : load yaw rate;
  int loadnavStatus = 0:0-bad,1-good;
  char loadAttached = 0:0-not attached 1-attached Slung Load attached flag;
  char loadwow = 1 :load weight on wheels;
  Double dcm_bl[3][3] = {{1,0,0},{0,1,0},{0,0,1}} :DCM body to inertial;
  Double dcm_lb[3][3] = {{1,0,0},{0,1,0},{0,0,1}} :DCM inertial to body;
  double latitude  = 0.0 :(deg-N);
  double longitude = 0.0 :(deg-E);
  double altitudeMSL = 0.0 :(ft) MSL;
  double v_a_e_L[3] = {0,0,0} :(ft/s) wind;
  double densityr = 1.0 :density ratio;
  double sunAzimuth = 0 : (degrees) azimuth to estimated location of the sun;
  double sunElevation = 0 : (degrees) angle of estimated elevation of the sun;
  
  double batteryPercent = 100 :how much power the battery will have;

} navout;

%define NAVTH_OUTLIER_NOCHECK 0
%define NAVTH_OUTLIER_FIXEDSIZE 1
%define NAVTH_OUTLIER_CHI2 2

%Dir navTh_ref {
  char  outlierDetect          = NAVTH_OUTLIER_CHI2 :0=off,1=fixed,2=chi2;
  uchar nignore                = 3 :number of valid readings before resetting terrain height;
  uchar outlierAdjustsAltitude = 0 :resetting altitude instead of terrain height;
  uchar sonarSlantRange        = 0 :use slant range for AGL sensor;
  uchar flagBadData = 0    : ;
  Char align[3] = {0,0,0} : ;
  double Pwow = 1.0       :if AGL covariance exceeds, do not know where ground is compared to us;
  double errorLimit = 0.25 :(ft) outlier detect limit;
  double chi2limit  = 0.5   :chi2 test limit (0.46 is 50%);
  double chi2mlimit = 1.0   :chi2m test limit;
  Double direction_B[3] = {0,0,1} :sensor direction in body when slant range used;
  double measuredTh  = 0   :(ft) measured th;
  double measuredThOld = 0 :(ft) previous measured th;
  double Ragl  = 0.02 :(ft2) cov of AGL sensor;
  double chi2  = 0.0  :Chi^2 test on residual;
  double chi2m = 0.0  :Chi^2 test between current and last measurement;
  double thEnvelopeGain = 0.0 :should be one, zero turns this off;
  double thEnvelope = 0.0 :(ft) do not trust measurments with higher than this;
  double minAllowedAGL = 0.0 :(ft) if >0, then AGL will not be less than this if got an OOR AGL hit;
} navTh;
%define MAX_AGL_MEASUREMENTS_TO_TEST 32*8

%Dir navWork_ref {
  long imuUpdate    = 0 :imu update;
  long gpsUpdatePos = 0 :gps update;
  long gpsUpdateVel = 0 :gps update;
  long gpsHdgUpdate = 0 :gps update;
  long gpsUpdateTC  = 0 :gps update;
  long magUpdate    = 0 :magnetometer update;
  long sonUpdate    = 0 :sonar update;
  long radUpdate    = 0 :radar update;
  long rfUpdate     = 0 :range finder update;
  long hubUpdate    = 0 :hub update;
  long hubUpdateTime = 0 :hub update arrival itime;
  long airUpdate    = 0 :air update;
  long airUpdateVel = 0 :air update dynamic pressure;
  long ofUpdate     = 0 :of update;
  long fpUpdate     = 0 :fp update;
  long impfUpdate   = 0 :impf update;
  long slamUpdate   = 0 :slam device update;
  long align_long = 0 :even number of longs;

  int checkCount = 1 :check for over run;
  uchar overrun = 0   :time overrun occured;
  uchar align1 = 0   :byte alignment;
  uchar missed = 0     :missed imu packets;
  char navStatus = 0 :status of nav system;

  int autoDatumPackets = 0 :(packets);
  uchar waitForDatum  = 0 : ;
  uchar waitForIMUBIT = 0 : ;
  uchar waitForAirBIT = 0 : ;
  schar waitForGPSPos = 0 : ;

  schar waitForGPSVel = 0 : ;
  schar waitForMagnet = 0 : ;
  schar waitForAir    = 0 : ;
  schar waitForSats   = 0 : ;
  uchar switchFromVision2GPS = 0 :flag to set cmded position to current location when returning to gps from vision nav;
  char  sonarSaysOnGround    = 1 :for sonar used to detect wow, 1=yes, 2=no;
  uchar maxPacketCopy      = 100 :maximum number of times to re-use the same IMU packet, use 255 for no limit;
  uchar switchFromGPS2AirAltitude = 0 :flag for switch;

  uchar switchFromAir2GPSAltitude = 0 :flag for switch;
  uchar aglSensorLandingLockoutStatus = 0 :Flag for locking out the AGL sensor landing method - requires a backup air to ground switch mechanism (0=good, 1=warn, 2=locked out);
  uchar aglSensorLandingCanUnlock = 1 :Flag for determining whether the AGL sensor landing method can be unlocked if currently locked out;
  uchar aglSensorNumMeasureHeld   = 0 :The current number of AGL sensor measurements being tested;
  uchar aglSensorRejected         = 0 :The current number of AGL sensor measurements rejected;
  char  sonarRawSaysOnGround    = 1 :for sonar used to detect wow, 1=yes, 2=no;
  Char align[2] = {0,0} : ;

  Uint aglHeathTest[8]  = {0,0,0,0,0,0,0,0} : Whether the measurement was thrown out;
  
  double p_magb     = 0 : (rad^2) measured filter popagation time ;
  double psi_bias     = 0 : (rad) measured filter popagation time ;
  Double gpsVelRes[3]    = {0,0,0} : (ft/s) gps velocity residual ;
  double propagateDt     = 0 : (s) measured filter popagation time ;
  double imuUpdateDt     = 0 : (s) imu popagation time ;
  double baseSensorsUpdateDt = 0 : (s) gps, air, sonar, mag, lrf, OF update time ;
  double visionUpdateDt  = 0 : (s) measured filter popagation time ;
  double sumDt  = 0 : (s) measured filter popagation time ;
  double w_b_e_B_meas[3] = {0,0,0} :(rad/s) measured angular rate of body wrt Earth expressed in body;
  double w_b_e_B[3]      = {0,0,0} :angular rate of body wrt Earth expressed in body;
  Double wo_b_e_B[3]     = {0,0,0} :old angular vel of body wrt Earth expressed in body;
  Double wd_b_e_B[3]     = {0,0,0} :angular accel of body wrt Earth expressed in body;
  double s_b_e_B_meas[3] = {0,0,0} :(ft/s2) measured spec force wrt Earth expressed in body frame;
  double s_b_e_B[3]      = {0,0,0} :spec force wrt Earth expressed in body frame;
  Double so_b_e_B[3]     = {0,0,0} :old accelerometer data;
  Double fil_s_b_e_B[3]  = {0,0,0} :filtered accel data;
  double gravity = 32.174  :gravity (ft/s2);
  Double m_L[3] = {0.567,-0.047,0.822} :(nT) calibrated mag field in local;
  double m_psi = 0.0 :(rad) mag north direction;
  double altitudeAGL = 25.0/12 :altitude of c.g. from sonar (ft);
  double wowFilter = 1 :filtered wow;
  double wowFilterSonar = 1 :filtered wow (sonar safe mode);
  double wowFilterSonarRaw = 1 :filtered wow (raw sonar mode);
  double timeRotorSpin = 0 :(sec);
  double timeRotorStartup = 0 :(sec) counts down from rotorSpinTime to 1 - may hold at 2 if rotor RPM match required;
  double inferFilt = 0 :(WOW_INFER);
  double inferTest = 0 :(WOW_INFER);
  double magr = 0 :(rad) mag residual wo/ bias, (bias is ~ minus this);
  Double dcm_bl[3][3] = {{1,0,0},{0,1,0},{0,0,1}} :DCM body to inertial;
  Double dcm_lb[3][3] = {{1,0,0},{0,1,0},{0,0,1}} :DCM inertial to body;
  Double dcm_lv[3][3] = {{1,0,0},{0,1,0},{0,0,1}} :DCM inertial to velocity;
  double freqAccelBias = 0      :(Hz) accel bias frequency;
  double oldAbsPress = 14.695 :(psi);

  Double w_b_e_B_lp[3]     = {0,0,0} : ;
  Double w_b_e_B_hp[3]     = {0,0,0} : ;
  Double pseudoPIDState[3] = {0,0,0} : ;
  Double leadLagState[3]   = {0,0,0} : ;
  double w_b_e_B_sas[3]    = {0,0,0} : ;

  int gpsInits = 0 : ;
  int gpsVelInits = 0 : ;
  int satInits = 0 : ;
  int magInits = 0 : ;
  int sonInits = 0 : ;
  int airInits = 0 : ;
} navWork;

%Dir navigation_ref {
  char mode = 0 :0=flight, 1=truth, 2=truth except wind, 3=truth for slungload, flight for heli, 4=truth from external software;
  dir navinit_ref      navinit      = navinit         :settings;
  dir navconfigure_ref navconfigure = navconfigure    :settings;
  dir navset_ref       set          = navset          :settings;
  dir navWork_ref      work         = navWork         :work area;
  dir dted_ref         dted         = dted            :digital terrain elevation data;
  dir navTh_ref        th           = navTh           :terrain height data;
  dir navout_ref       out          = navout          :output structure (to control);
} navigation;
